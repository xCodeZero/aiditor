"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/q";
exports.ids = ["vendor-chunks/q"];
exports.modules = {

/***/ "(rsc)/./node_modules/q/q.js":
/*!*****************************!*\
  !*** ./node_modules/q/q.js ***!
  \*****************************/
/***/ ((module) => {

eval("\n// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2017 Kris Kowal under the terms of the MIT\n * license found at https://github.com/kriskowal/q/blob/v1/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ (function(definition) {\n    \"use strict\";\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n    // CommonJS\n    } else if (true) {\n        module.exports = definition();\n    // RequireJS\n    } else { var previousQ, global; }\n})(function() {\n    \"use strict\";\n    var hasStacks = false;\n    try {\n        throw new Error();\n    } catch (e) {\n        hasStacks = !!e.stack;\n    }\n    // All code after this point will be filtered from stack traces reported\n    // by Q.\n    var qStartingLine = captureLine();\n    var qFileName;\n    // shims\n    // used for fallback in \"allResolved\"\n    var noop = function() {};\n    // Use the fastest possible means to execute a task in a future turn\n    // of the event loop.\n    var nextTick = function() {\n        // linked list of tasks (single, with head node)\n        var head = {\n            task: void 0,\n            next: null\n        };\n        var tail = head;\n        var flushing = false;\n        var requestTick = void 0;\n        var isNodeJS = false;\n        // queue for late tasks, used by unhandled rejection tracking\n        var laterQueue = [];\n        function flush() {\n            /* jshint loopfunc: true */ var task, domain;\n            while(head.next){\n                head = head.next;\n                task = head.task;\n                head.task = void 0;\n                domain = head.domain;\n                if (domain) {\n                    head.domain = void 0;\n                    domain.enter();\n                }\n                runSingle(task, domain);\n            }\n            while(laterQueue.length){\n                task = laterQueue.pop();\n                runSingle(task);\n            }\n            flushing = false;\n        }\n        // runs a single function in the async queue\n        function runSingle(task, domain) {\n            try {\n                task();\n            } catch (e) {\n                if (isNodeJS) {\n                    // In node, uncaught exceptions are considered fatal errors.\n                    // Re-throw them synchronously to interrupt flushing!\n                    // Ensure continuation if the uncaught exception is suppressed\n                    // listening \"uncaughtException\" events (as domains does).\n                    // Continue in next event to avoid tick recursion.\n                    if (domain) {\n                        domain.exit();\n                    }\n                    setTimeout(flush, 0);\n                    if (domain) {\n                        domain.enter();\n                    }\n                    throw e;\n                } else {\n                    // In browsers, uncaught exceptions are not fatal.\n                    // Re-throw them asynchronously to avoid slow-downs.\n                    setTimeout(function() {\n                        throw e;\n                    }, 0);\n                }\n            }\n            if (domain) {\n                domain.exit();\n            }\n        }\n        nextTick = function(task) {\n            tail = tail.next = {\n                task: task,\n                domain: isNodeJS && process.domain,\n                next: null\n            };\n            if (!flushing) {\n                flushing = true;\n                requestTick();\n            }\n        };\n        if (typeof process === \"object\" && process.toString() === \"[object process]\" && process.nextTick) {\n            // Ensure Q is in a real Node environment, with a `process.nextTick`.\n            // To see through fake Node environments:\n            // * Mocha test runner - exposes a `process` global without a `nextTick`\n            // * Browserify - exposes a `process.nexTick` function that uses\n            //   `setTimeout`. In this case `setImmediate` is preferred because\n            //    it is faster. Browserify's `process.toString()` yields\n            //   \"[object Object]\", while in a real Node environment\n            //   `process.toString()` yields \"[object process]\".\n            isNodeJS = true;\n            requestTick = function() {\n                process.nextTick(flush);\n            };\n        } else if (typeof setImmediate === \"function\") {\n            // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n            if (false) {} else {\n                requestTick = function() {\n                    setImmediate(flush);\n                };\n            }\n        } else if (typeof MessageChannel !== \"undefined\") {\n            // modern browsers\n            // http://www.nonblocking.io/2011/06/windownexttick.html\n            var channel = new MessageChannel();\n            // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n            // working message ports the first time a page loads.\n            channel.port1.onmessage = function() {\n                requestTick = requestPortTick;\n                channel.port1.onmessage = flush;\n                flush();\n            };\n            var requestPortTick = function() {\n                // Opera requires us to provide a message payload, regardless of\n                // whether we use it.\n                channel.port2.postMessage(0);\n            };\n            requestTick = function() {\n                setTimeout(flush, 0);\n                requestPortTick();\n            };\n        } else {\n            // old browsers\n            requestTick = function() {\n                setTimeout(flush, 0);\n            };\n        }\n        // runs a task after all other tasks have been run\n        // this is useful for unhandled rejection tracking that needs to happen\n        // after all `then`d tasks have been run.\n        nextTick.runAfter = function(task) {\n            laterQueue.push(task);\n            if (!flushing) {\n                flushing = true;\n                requestTick();\n            }\n        };\n        return nextTick;\n    }();\n    // Attempt to make generics safe in the face of downstream\n    // modifications.\n    // There is no situation where this is necessary.\n    // If you need a security guarantee, these primordials need to be\n    // deeply frozen anyway, and if you don’t need a security guarantee,\n    // this is just plain paranoid.\n    // However, this **might** have the nice side-effect of reducing the size of\n    // the minified code by reducing x.call() to merely x()\n    // See Mark Miller’s explanation of what this does.\n    // http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\n    var call = Function.call;\n    function uncurryThis(f) {\n        return function() {\n            return call.apply(f, arguments);\n        };\n    }\n    // This is equivalent, but slower:\n    // uncurryThis = Function_bind.bind(Function_bind.call);\n    // http://jsperf.com/uncurrythis\n    var array_slice = uncurryThis(Array.prototype.slice);\n    var array_reduce = uncurryThis(Array.prototype.reduce || function(callback, basis) {\n        var index = 0, length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            }while (1);\n        }\n        // reduce\n        for(; index < length; index++){\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    });\n    var array_indexOf = uncurryThis(Array.prototype.indexOf || function(value) {\n        // not a very good shim, but good enough for our one use of it\n        for(var i = 0; i < this.length; i++){\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    });\n    var array_map = uncurryThis(Array.prototype.map || function(callback, thisp) {\n        var self1 = this;\n        var collect = [];\n        array_reduce(self1, function(undefined1, value, index) {\n            collect.push(callback.call(thisp, value, index, self1));\n        }, void 0);\n        return collect;\n    });\n    var object_create = Object.create || function(prototype) {\n        function Type() {}\n        Type.prototype = prototype;\n        return new Type();\n    };\n    var object_defineProperty = Object.defineProperty || function(obj, prop, descriptor) {\n        obj[prop] = descriptor.value;\n        return obj;\n    };\n    var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n    var object_keys = Object.keys || function(object) {\n        var keys = [];\n        for(var key in object){\n            if (object_hasOwnProperty(object, key)) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    };\n    var object_toString = uncurryThis(Object.prototype.toString);\n    function isObject(value) {\n        return value === Object(value);\n    }\n    // generator related shims\n    // FIXME: Remove this function once ES6 generators are in SpiderMonkey.\n    function isStopIteration(exception) {\n        return object_toString(exception) === \"[object StopIteration]\" || exception instanceof QReturnValue;\n    }\n    // FIXME: Remove this helper and Q.return once ES6 generators are in\n    // SpiderMonkey.\n    var QReturnValue;\n    if (typeof ReturnValue !== \"undefined\") {\n        QReturnValue = ReturnValue;\n    } else {\n        QReturnValue = function(value) {\n            this.value = value;\n        };\n    }\n    // long stack traces\n    var STACK_JUMP_SEPARATOR = \"From previous event:\";\n    function makeStackTraceLong(error, promise) {\n        // If possible, transform the error stack trace by removing Node and Q\n        // cruft, then concatenating with the stack trace of `promise`. See #57.\n        if (hasStacks && promise.stack && typeof error === \"object\" && error !== null && error.stack) {\n            var stacks = [];\n            for(var p = promise; !!p; p = p.source){\n                if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {\n                    object_defineProperty(error, \"__minimumStackCounter__\", {\n                        value: p.stackCounter,\n                        configurable: true\n                    });\n                    stacks.unshift(p.stack);\n                }\n            }\n            stacks.unshift(error.stack);\n            var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n            var stack = filterStackString(concatedStacks);\n            object_defineProperty(error, \"stack\", {\n                value: stack,\n                configurable: true\n            });\n        }\n    }\n    function filterStackString(stackString) {\n        var lines = stackString.split(\"\\n\");\n        var desiredLines = [];\n        for(var i = 0; i < lines.length; ++i){\n            var line = lines[i];\n            if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n                desiredLines.push(line);\n            }\n        }\n        return desiredLines.join(\"\\n\");\n    }\n    function isNodeFrame(stackLine) {\n        return stackLine.indexOf(\"(module.js:\") !== -1 || stackLine.indexOf(\"(node.js:\") !== -1;\n    }\n    function getFileNameAndLineNumber(stackLine) {\n        // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n        // In IE10 function name can have spaces (\"Anonymous function\") O_o\n        var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n        if (attempt1) {\n            return [\n                attempt1[1],\n                Number(attempt1[2])\n            ];\n        }\n        // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n        var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n        if (attempt2) {\n            return [\n                attempt2[1],\n                Number(attempt2[2])\n            ];\n        }\n        // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n        var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n        if (attempt3) {\n            return [\n                attempt3[1],\n                Number(attempt3[2])\n            ];\n        }\n    }\n    function isInternalFrame(stackLine) {\n        var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n        if (!fileNameAndLineNumber) {\n            return false;\n        }\n        var fileName = fileNameAndLineNumber[0];\n        var lineNumber = fileNameAndLineNumber[1];\n        return fileName === qFileName && lineNumber >= qStartingLine && lineNumber <= qEndingLine;\n    }\n    // discover own file name and line number range for filtering stack\n    // traces\n    function captureLine() {\n        if (!hasStacks) {\n            return;\n        }\n        try {\n            throw new Error();\n        } catch (e) {\n            var lines = e.stack.split(\"\\n\");\n            var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n            var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n            if (!fileNameAndLineNumber) {\n                return;\n            }\n            qFileName = fileNameAndLineNumber[0];\n            return fileNameAndLineNumber[1];\n        }\n    }\n    function deprecate(callback, name, alternative) {\n        return function() {\n            if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n                console.warn(name + \" is deprecated, use \" + alternative + \" instead.\", new Error(\"\").stack);\n            }\n            return callback.apply(callback, arguments);\n        };\n    }\n    // end of shims\n    // beginning of real work\n    /**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */ function Q(value) {\n        // If the object is already a Promise, return it directly.  This enables\n        // the resolve function to both be used to created references from objects,\n        // but to tolerably coerce non-promises to promises.\n        if (value instanceof Promise) {\n            return value;\n        }\n        // assimilate thenables\n        if (isPromiseAlike(value)) {\n            return coerce(value);\n        } else {\n            return fulfill(value);\n        }\n    }\n    Q.resolve = Q;\n    /**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */ Q.nextTick = nextTick;\n    /**\n * Controls whether or not long stack traces will be on\n */ Q.longStackSupport = false;\n    /**\n * The counter is used to determine the stopping point for building\n * long stack traces. In makeStackTraceLong we walk backwards through\n * the linked list of promises, only stacks which were created before\n * the rejection are concatenated.\n */ var longStackCounter = 1;\n    // enable long stacks if Q_DEBUG is set\n    if (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n        Q.longStackSupport = true;\n    }\n    /**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */ Q.defer = defer;\n    function defer() {\n        // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n        // been resolved.  If it is \"undefined\", it has been resolved.  Each\n        // element of the messages array is itself an array of complete arguments to\n        // forward to the resolved promise.  We coerce the resolution value to a\n        // promise using the `resolve` function because it handles both fully\n        // non-thenable values and other thenables gracefully.\n        var messages = [], progressListeners = [], resolvedPromise;\n        var deferred = object_create(defer.prototype);\n        var promise = object_create(Promise.prototype);\n        promise.promiseDispatch = function(resolve, op, operands) {\n            var args = array_slice(arguments);\n            if (messages) {\n                messages.push(args);\n                if (op === \"when\" && operands[1]) {\n                    progressListeners.push(operands[1]);\n                }\n            } else {\n                Q.nextTick(function() {\n                    resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n                });\n            }\n        };\n        // XXX deprecated\n        promise.valueOf = function() {\n            if (messages) {\n                return promise;\n            }\n            var nearerValue = nearer(resolvedPromise);\n            if (isPromise(nearerValue)) {\n                resolvedPromise = nearerValue; // shorten chain\n            }\n            return nearerValue;\n        };\n        promise.inspect = function() {\n            if (!resolvedPromise) {\n                return {\n                    state: \"pending\"\n                };\n            }\n            return resolvedPromise.inspect();\n        };\n        if (Q.longStackSupport && hasStacks) {\n            try {\n                throw new Error();\n            } catch (e) {\n                // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n                // accessor around; that causes memory leaks as per GH-111. Just\n                // reify the stack trace as a string ASAP.\n                //\n                // At the same time, cut off the first line; it's always just\n                // \"[object Promise]\\n\", as per the `toString`.\n                promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n                promise.stackCounter = longStackCounter++;\n            }\n        }\n        // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n        // consolidating them into `become`, since otherwise we'd create new\n        // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n        function become(newPromise) {\n            resolvedPromise = newPromise;\n            if (Q.longStackSupport && hasStacks) {\n                // Only hold a reference to the new promise if long stacks\n                // are enabled to reduce memory usage\n                promise.source = newPromise;\n            }\n            array_reduce(messages, function(undefined1, message) {\n                Q.nextTick(function() {\n                    newPromise.promiseDispatch.apply(newPromise, message);\n                });\n            }, void 0);\n            messages = void 0;\n            progressListeners = void 0;\n        }\n        deferred.promise = promise;\n        deferred.resolve = function(value) {\n            if (resolvedPromise) {\n                return;\n            }\n            become(Q(value));\n        };\n        deferred.fulfill = function(value) {\n            if (resolvedPromise) {\n                return;\n            }\n            become(fulfill(value));\n        };\n        deferred.reject = function(reason) {\n            if (resolvedPromise) {\n                return;\n            }\n            become(reject(reason));\n        };\n        deferred.notify = function(progress) {\n            if (resolvedPromise) {\n                return;\n            }\n            array_reduce(progressListeners, function(undefined1, progressListener) {\n                Q.nextTick(function() {\n                    progressListener(progress);\n                });\n            }, void 0);\n        };\n        return deferred;\n    }\n    /**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */ defer.prototype.makeNodeResolver = function() {\n        var self1 = this;\n        return function(error, value) {\n            if (error) {\n                self1.reject(error);\n            } else if (arguments.length > 2) {\n                self1.resolve(array_slice(arguments, 1));\n            } else {\n                self1.resolve(value);\n            }\n        };\n    };\n    /**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */ Q.Promise = promise; // ES6\n    Q.promise = promise;\n    function promise(resolver) {\n        if (typeof resolver !== \"function\") {\n            throw new TypeError(\"resolver must be a function.\");\n        }\n        var deferred = defer();\n        try {\n            resolver(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (reason) {\n            deferred.reject(reason);\n        }\n        return deferred.promise;\n    }\n    promise.race = race; // ES6\n    promise.all = all; // ES6\n    promise.reject = reject; // ES6\n    promise.resolve = Q; // ES6\n    // XXX experimental.  This method is a way to denote that a local value is\n    // serializable and should be immediately dispatched to a remote upon request,\n    // instead of passing a reference.\n    Q.passByCopy = function(object) {\n        //freeze(object);\n        //passByCopies.set(object, true);\n        return object;\n    };\n    Promise.prototype.passByCopy = function() {\n        //freeze(object);\n        //passByCopies.set(object, true);\n        return this;\n    };\n    /**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */ Q.join = function(x, y) {\n        return Q(x).join(y);\n    };\n    Promise.prototype.join = function(that) {\n        return Q([\n            this,\n            that\n        ]).spread(function(x, y) {\n            if (x === y) {\n                // TODO: \"===\" should be Object.is or equiv\n                return x;\n            } else {\n                throw new Error(\"Q can't join: not the same: \" + x + \" \" + y);\n            }\n        });\n    };\n    /**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */ Q.race = race;\n    function race(answerPs) {\n        return promise(function(resolve, reject) {\n            // Switch to this once we can assume at least ES5\n            // answerPs.forEach(function (answerP) {\n            //     Q(answerP).then(resolve, reject);\n            // });\n            // Use this in the meantime\n            for(var i = 0, len = answerPs.length; i < len; i++){\n                Q(answerPs[i]).then(resolve, reject);\n            }\n        });\n    }\n    Promise.prototype.race = function() {\n        return this.then(Q.race);\n    };\n    /**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */ Q.makePromise = Promise;\n    function Promise(descriptor, fallback, inspect) {\n        if (fallback === void 0) {\n            fallback = function(op) {\n                return reject(new Error(\"Promise does not support operation: \" + op));\n            };\n        }\n        if (inspect === void 0) {\n            inspect = function() {\n                return {\n                    state: \"unknown\"\n                };\n            };\n        }\n        var promise = object_create(Promise.prototype);\n        promise.promiseDispatch = function(resolve, op, args) {\n            var result;\n            try {\n                if (descriptor[op]) {\n                    result = descriptor[op].apply(promise, args);\n                } else {\n                    result = fallback.call(promise, op, args);\n                }\n            } catch (exception) {\n                result = reject(exception);\n            }\n            if (resolve) {\n                resolve(result);\n            }\n        };\n        promise.inspect = inspect;\n        // XXX deprecated `valueOf` and `exception` support\n        if (inspect) {\n            var inspected = inspect();\n            if (inspected.state === \"rejected\") {\n                promise.exception = inspected.reason;\n            }\n            promise.valueOf = function() {\n                var inspected = inspect();\n                if (inspected.state === \"pending\" || inspected.state === \"rejected\") {\n                    return promise;\n                }\n                return inspected.value;\n            };\n        }\n        return promise;\n    }\n    Promise.prototype.toString = function() {\n        return \"[object Promise]\";\n    };\n    Promise.prototype.then = function(fulfilled, rejected, progressed) {\n        var self1 = this;\n        var deferred = defer();\n        var done = false; // ensure the untrusted promise makes at most a\n        // single call to one of the callbacks\n        function _fulfilled(value) {\n            try {\n                return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n            } catch (exception) {\n                return reject(exception);\n            }\n        }\n        function _rejected(exception) {\n            if (typeof rejected === \"function\") {\n                makeStackTraceLong(exception, self1);\n                try {\n                    return rejected(exception);\n                } catch (newException) {\n                    return reject(newException);\n                }\n            }\n            return reject(exception);\n        }\n        function _progressed(value) {\n            return typeof progressed === \"function\" ? progressed(value) : value;\n        }\n        Q.nextTick(function() {\n            self1.promiseDispatch(function(value) {\n                if (done) {\n                    return;\n                }\n                done = true;\n                deferred.resolve(_fulfilled(value));\n            }, \"when\", [\n                function(exception) {\n                    if (done) {\n                        return;\n                    }\n                    done = true;\n                    deferred.resolve(_rejected(exception));\n                }\n            ]);\n        });\n        // Progress propagator need to be attached in the current tick.\n        self1.promiseDispatch(void 0, \"when\", [\n            void 0,\n            function(value) {\n                var newValue;\n                var threw = false;\n                try {\n                    newValue = _progressed(value);\n                } catch (e) {\n                    threw = true;\n                    if (Q.onerror) {\n                        Q.onerror(e);\n                    } else {\n                        throw e;\n                    }\n                }\n                if (!threw) {\n                    deferred.notify(newValue);\n                }\n            }\n        ]);\n        return deferred.promise;\n    };\n    Q.tap = function(promise, callback) {\n        return Q(promise).tap(callback);\n    };\n    /**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */ Promise.prototype.tap = function(callback) {\n        callback = Q(callback);\n        return this.then(function(value) {\n            return callback.fcall(value).thenResolve(value);\n        });\n    };\n    /**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */ Q.when = when;\n    function when(value, fulfilled, rejected, progressed) {\n        return Q(value).then(fulfilled, rejected, progressed);\n    }\n    Promise.prototype.thenResolve = function(value) {\n        return this.then(function() {\n            return value;\n        });\n    };\n    Q.thenResolve = function(promise, value) {\n        return Q(promise).thenResolve(value);\n    };\n    Promise.prototype.thenReject = function(reason) {\n        return this.then(function() {\n            throw reason;\n        });\n    };\n    Q.thenReject = function(promise, reason) {\n        return Q(promise).thenReject(reason);\n    };\n    /**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If it’s a fulfilled promise, the fulfillment value is nearer.\n * If it’s a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */ // XXX should we re-do this?\n    Q.nearer = nearer;\n    function nearer(value) {\n        if (isPromise(value)) {\n            var inspected = value.inspect();\n            if (inspected.state === \"fulfilled\") {\n                return inspected.value;\n            }\n        }\n        return value;\n    }\n    /**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */ Q.isPromise = isPromise;\n    function isPromise(object) {\n        return object instanceof Promise;\n    }\n    Q.isPromiseAlike = isPromiseAlike;\n    function isPromiseAlike(object) {\n        return isObject(object) && typeof object.then === \"function\";\n    }\n    /**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */ Q.isPending = isPending;\n    function isPending(object) {\n        return isPromise(object) && object.inspect().state === \"pending\";\n    }\n    Promise.prototype.isPending = function() {\n        return this.inspect().state === \"pending\";\n    };\n    /**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */ Q.isFulfilled = isFulfilled;\n    function isFulfilled(object) {\n        return !isPromise(object) || object.inspect().state === \"fulfilled\";\n    }\n    Promise.prototype.isFulfilled = function() {\n        return this.inspect().state === \"fulfilled\";\n    };\n    /**\n * @returns whether the given object is a rejected promise.\n */ Q.isRejected = isRejected;\n    function isRejected(object) {\n        return isPromise(object) && object.inspect().state === \"rejected\";\n    }\n    Promise.prototype.isRejected = function() {\n        return this.inspect().state === \"rejected\";\n    };\n    //// BEGIN UNHANDLED REJECTION TRACKING\n    // This promise library consumes exceptions thrown in handlers so they can be\n    // handled by a subsequent promise.  The exceptions get added to this array when\n    // they are created, and removed when they are handled.  Note that in ES6 or\n    // shimmed environments, this would naturally be a `Set`.\n    var unhandledReasons = [];\n    var unhandledRejections = [];\n    var reportedUnhandledRejections = [];\n    var trackUnhandledRejections = true;\n    function resetUnhandledRejections() {\n        unhandledReasons.length = 0;\n        unhandledRejections.length = 0;\n        if (!trackUnhandledRejections) {\n            trackUnhandledRejections = true;\n        }\n    }\n    function trackRejection(promise, reason) {\n        if (!trackUnhandledRejections) {\n            return;\n        }\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function() {\n                if (array_indexOf(unhandledRejections, promise) !== -1) {\n                    process.emit(\"unhandledRejection\", reason, promise);\n                    reportedUnhandledRejections.push(promise);\n                }\n            });\n        }\n        unhandledRejections.push(promise);\n        if (reason && typeof reason.stack !== \"undefined\") {\n            unhandledReasons.push(reason.stack);\n        } else {\n            unhandledReasons.push(\"(no stack) \" + reason);\n        }\n    }\n    function untrackRejection(promise) {\n        if (!trackUnhandledRejections) {\n            return;\n        }\n        var at = array_indexOf(unhandledRejections, promise);\n        if (at !== -1) {\n            if (typeof process === \"object\" && typeof process.emit === \"function\") {\n                Q.nextTick.runAfter(function() {\n                    var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                    if (atReport !== -1) {\n                        process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                        reportedUnhandledRejections.splice(atReport, 1);\n                    }\n                });\n            }\n            unhandledRejections.splice(at, 1);\n            unhandledReasons.splice(at, 1);\n        }\n    }\n    Q.resetUnhandledRejections = resetUnhandledRejections;\n    Q.getUnhandledReasons = function() {\n        // Make a copy so that consumers can't interfere with our internal state.\n        return unhandledReasons.slice();\n    };\n    Q.stopUnhandledRejectionTracking = function() {\n        resetUnhandledRejections();\n        trackUnhandledRejections = false;\n    };\n    resetUnhandledRejections();\n    //// END UNHANDLED REJECTION TRACKING\n    /**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */ Q.reject = reject;\n    function reject(reason) {\n        var rejection = Promise({\n            \"when\": function(rejected) {\n                // note that the error has been handled\n                if (rejected) {\n                    untrackRejection(this);\n                }\n                return rejected ? rejected(reason) : this;\n            }\n        }, function fallback() {\n            return this;\n        }, function inspect() {\n            return {\n                state: \"rejected\",\n                reason: reason\n            };\n        });\n        // Note that the reason has not been handled.\n        trackRejection(rejection, reason);\n        return rejection;\n    }\n    /**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */ Q.fulfill = fulfill;\n    function fulfill(value) {\n        return Promise({\n            \"when\": function() {\n                return value;\n            },\n            \"get\": function(name) {\n                return value[name];\n            },\n            \"set\": function(name, rhs) {\n                value[name] = rhs;\n            },\n            \"delete\": function(name) {\n                delete value[name];\n            },\n            \"post\": function(name, args) {\n                // Mark Miller proposes that post with no name should apply a\n                // promised function.\n                if (name === null || name === void 0) {\n                    return value.apply(void 0, args);\n                } else {\n                    return value[name].apply(value, args);\n                }\n            },\n            \"apply\": function(thisp, args) {\n                return value.apply(thisp, args);\n            },\n            \"keys\": function() {\n                return object_keys(value);\n            }\n        }, void 0, function inspect() {\n            return {\n                state: \"fulfilled\",\n                value: value\n            };\n        });\n    }\n    /**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */ function coerce(promise) {\n        var deferred = defer();\n        Q.nextTick(function() {\n            try {\n                promise.then(deferred.resolve, deferred.reject, deferred.notify);\n            } catch (exception) {\n                deferred.reject(exception);\n            }\n        });\n        return deferred.promise;\n    }\n    /**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */ Q.master = master;\n    function master(object) {\n        return Promise({\n            \"isDef\": function() {}\n        }, function fallback(op, args) {\n            return dispatch(object, op, args);\n        }, function() {\n            return Q(object).inspect();\n        });\n    }\n    /**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */ Q.spread = spread;\n    function spread(value, fulfilled, rejected) {\n        return Q(value).spread(fulfilled, rejected);\n    }\n    Promise.prototype.spread = function(fulfilled, rejected) {\n        return this.all().then(function(array) {\n            return fulfilled.apply(void 0, array);\n        }, rejected);\n    };\n    /**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */ Q.async = async;\n    function async(makeGenerator) {\n        return function() {\n            // when verb is \"send\", arg is a value\n            // when verb is \"throw\", arg is an exception\n            function continuer(verb, arg) {\n                var result;\n                // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n                // engine that has a deployed base of browsers that support generators.\n                // However, SM's generators use the Python-inspired semantics of\n                // outdated ES6 drafts.  We would like to support ES6, but we'd also\n                // like to make it possible to use generators in deployed browsers, so\n                // we also support Python-style generators.  At some point we can remove\n                // this block.\n                if (typeof StopIteration === \"undefined\") {\n                    // ES6 Generators\n                    try {\n                        result = generator[verb](arg);\n                    } catch (exception) {\n                        return reject(exception);\n                    }\n                    if (result.done) {\n                        return Q(result.value);\n                    } else {\n                        return when(result.value, callback, errback);\n                    }\n                } else {\n                    // SpiderMonkey Generators\n                    // FIXME: Remove this case when SM does ES6 generators.\n                    try {\n                        result = generator[verb](arg);\n                    } catch (exception) {\n                        if (isStopIteration(exception)) {\n                            return Q(exception.value);\n                        } else {\n                            return reject(exception);\n                        }\n                    }\n                    return when(result, callback, errback);\n                }\n            }\n            var generator = makeGenerator.apply(this, arguments);\n            var callback = continuer.bind(continuer, \"next\");\n            var errback = continuer.bind(continuer, \"throw\");\n            return callback();\n        };\n    }\n    /**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */ Q.spawn = spawn;\n    function spawn(makeGenerator) {\n        Q.done(Q.async(makeGenerator)());\n    }\n    // FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n    /**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */ Q[\"return\"] = _return;\n    function _return(value) {\n        throw new QReturnValue(value);\n    }\n    /**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */ Q.promised = promised;\n    function promised(callback) {\n        return function() {\n            return spread([\n                this,\n                all(arguments)\n            ], function(self1, args) {\n                return callback.apply(self1, args);\n            });\n        };\n    }\n    /**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */ Q.dispatch = dispatch;\n    function dispatch(object, op, args) {\n        return Q(object).dispatch(op, args);\n    }\n    Promise.prototype.dispatch = function(op, args) {\n        var self1 = this;\n        var deferred = defer();\n        Q.nextTick(function() {\n            self1.promiseDispatch(deferred.resolve, op, args);\n        });\n        return deferred.promise;\n    };\n    /**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */ Q.get = function(object, key) {\n        return Q(object).dispatch(\"get\", [\n            key\n        ]);\n    };\n    Promise.prototype.get = function(key) {\n        return this.dispatch(\"get\", [\n            key\n        ]);\n    };\n    /**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */ Q.set = function(object, key, value) {\n        return Q(object).dispatch(\"set\", [\n            key,\n            value\n        ]);\n    };\n    Promise.prototype.set = function(key, value) {\n        return this.dispatch(\"set\", [\n            key,\n            value\n        ]);\n    };\n    /**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */ Q.del = Q[\"delete\"] = function(object, key) {\n        return Q(object).dispatch(\"delete\", [\n            key\n        ]);\n    };\n    Promise.prototype.del = Promise.prototype[\"delete\"] = function(key) {\n        return this.dispatch(\"delete\", [\n            key\n        ]);\n    };\n    /**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */ // bound locally because it is used by other methods\n    Q.mapply = Q.post = function(object, name, args) {\n        return Q(object).dispatch(\"post\", [\n            name,\n            args\n        ]);\n    };\n    Promise.prototype.mapply = Promise.prototype.post = function(name, args) {\n        return this.dispatch(\"post\", [\n            name,\n            args\n        ]);\n    };\n    /**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */ Q.send = Q.mcall = Q.invoke = function(object, name /*...args*/ ) {\n        return Q(object).dispatch(\"post\", [\n            name,\n            array_slice(arguments, 2)\n        ]);\n    };\n    Promise.prototype.send = Promise.prototype.mcall = Promise.prototype.invoke = function(name /*...args*/ ) {\n        return this.dispatch(\"post\", [\n            name,\n            array_slice(arguments, 1)\n        ]);\n    };\n    /**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */ Q.fapply = function(object, args) {\n        return Q(object).dispatch(\"apply\", [\n            void 0,\n            args\n        ]);\n    };\n    Promise.prototype.fapply = function(args) {\n        return this.dispatch(\"apply\", [\n            void 0,\n            args\n        ]);\n    };\n    /**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */ Q[\"try\"] = Q.fcall = function(object /* ...args*/ ) {\n        return Q(object).dispatch(\"apply\", [\n            void 0,\n            array_slice(arguments, 1)\n        ]);\n    };\n    Promise.prototype.fcall = function() {\n        return this.dispatch(\"apply\", [\n            void 0,\n            array_slice(arguments)\n        ]);\n    };\n    /**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */ Q.fbind = function(object /*...args*/ ) {\n        var promise = Q(object);\n        var args = array_slice(arguments, 1);\n        return function fbound() {\n            return promise.dispatch(\"apply\", [\n                this,\n                args.concat(array_slice(arguments))\n            ]);\n        };\n    };\n    Promise.prototype.fbind = function() {\n        var promise = this;\n        var args = array_slice(arguments);\n        return function fbound() {\n            return promise.dispatch(\"apply\", [\n                this,\n                args.concat(array_slice(arguments))\n            ]);\n        };\n    };\n    /**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */ Q.keys = function(object) {\n        return Q(object).dispatch(\"keys\", []);\n    };\n    Promise.prototype.keys = function() {\n        return this.dispatch(\"keys\", []);\n    };\n    /**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */ // By Mark Miller\n    // http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\n    Q.all = all;\n    function all(promises) {\n        return when(promises, function(promises) {\n            var pendingCount = 0;\n            var deferred = defer();\n            array_reduce(promises, function(undefined1, promise, index) {\n                var snapshot;\n                if (isPromise(promise) && (snapshot = promise.inspect()).state === \"fulfilled\") {\n                    promises[index] = snapshot.value;\n                } else {\n                    ++pendingCount;\n                    when(promise, function(value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    }, deferred.reject, function(progress) {\n                        deferred.notify({\n                            index: index,\n                            value: progress\n                        });\n                    });\n                }\n            }, void 0);\n            if (pendingCount === 0) {\n                deferred.resolve(promises);\n            }\n            return deferred.promise;\n        });\n    }\n    Promise.prototype.all = function() {\n        return all(this);\n    };\n    /**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */ Q.any = any;\n    function any(promises) {\n        if (promises.length === 0) {\n            return Q.resolve();\n        }\n        var deferred = Q.defer();\n        var pendingCount = 0;\n        array_reduce(promises, function(prev, current, index) {\n            var promise = promises[index];\n            pendingCount++;\n            when(promise, onFulfilled, onRejected, onProgress);\n            function onFulfilled(result) {\n                deferred.resolve(result);\n            }\n            function onRejected(err) {\n                pendingCount--;\n                if (pendingCount === 0) {\n                    var rejection = err || new Error(\"\" + err);\n                    rejection.message = \"Q can't get fulfillment value from any promise, all \" + \"promises were rejected. Last error message: \" + rejection.message;\n                    deferred.reject(rejection);\n                }\n            }\n            function onProgress(progress) {\n                deferred.notify({\n                    index: index,\n                    value: progress\n                });\n            }\n        }, undefined);\n        return deferred.promise;\n    }\n    Promise.prototype.any = function() {\n        return any(this);\n    };\n    /**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */ Q.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\n    function allResolved(promises) {\n        return when(promises, function(promises) {\n            promises = array_map(promises, Q);\n            return when(all(array_map(promises, function(promise) {\n                return when(promise, noop, noop);\n            })), function() {\n                return promises;\n            });\n        });\n    }\n    Promise.prototype.allResolved = function() {\n        return allResolved(this);\n    };\n    /**\n * @see Promise#allSettled\n */ Q.allSettled = allSettled;\n    function allSettled(promises) {\n        return Q(promises).allSettled();\n    }\n    /**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */ Promise.prototype.allSettled = function() {\n        return this.then(function(promises) {\n            return all(array_map(promises, function(promise) {\n                promise = Q(promise);\n                function regardless() {\n                    return promise.inspect();\n                }\n                return promise.then(regardless, regardless);\n            }));\n        });\n    };\n    /**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */ Q.fail = Q[\"catch\"] = function(object, rejected) {\n        return Q(object).then(void 0, rejected);\n    };\n    Promise.prototype.fail = Promise.prototype[\"catch\"] = function(rejected) {\n        return this.then(void 0, rejected);\n    };\n    /**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */ Q.progress = progress;\n    function progress(object, progressed) {\n        return Q(object).then(void 0, void 0, progressed);\n    }\n    Promise.prototype.progress = function(progressed) {\n        return this.then(void 0, void 0, progressed);\n    };\n    /**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */ Q.fin = Q[\"finally\"] = function(object, callback) {\n        return Q(object)[\"finally\"](callback);\n    };\n    Promise.prototype.fin = Promise.prototype[\"finally\"] = function(callback) {\n        if (!callback || typeof callback.apply !== \"function\") {\n            throw new Error(\"Q can't apply finally callback\");\n        }\n        callback = Q(callback);\n        return this.then(function(value) {\n            return callback.fcall().then(function() {\n                return value;\n            });\n        }, function(reason) {\n            // TODO attempt to recycle the rejection with \"this\".\n            return callback.fcall().then(function() {\n                throw reason;\n            });\n        });\n    };\n    /**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */ Q.done = function(object, fulfilled, rejected, progress) {\n        return Q(object).done(fulfilled, rejected, progress);\n    };\n    Promise.prototype.done = function(fulfilled, rejected, progress) {\n        var onUnhandledError = function(error) {\n            // forward to a future turn so that ``when``\n            // does not catch it and turn it into a rejection.\n            Q.nextTick(function() {\n                makeStackTraceLong(error, promise);\n                if (Q.onerror) {\n                    Q.onerror(error);\n                } else {\n                    throw error;\n                }\n            });\n        };\n        // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n        var promise = fulfilled || rejected || progress ? this.then(fulfilled, rejected, progress) : this;\n        if (typeof process === \"object\" && process && process.domain) {\n            onUnhandledError = process.domain.bind(onUnhandledError);\n        }\n        promise.then(void 0, onUnhandledError);\n    };\n    /**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */ Q.timeout = function(object, ms, error) {\n        return Q(object).timeout(ms, error);\n    };\n    Promise.prototype.timeout = function(ms, error) {\n        var deferred = defer();\n        var timeoutId = setTimeout(function() {\n            if (!error || \"string\" === typeof error) {\n                error = new Error(error || \"Timed out after \" + ms + \" ms\");\n                error.code = \"ETIMEDOUT\";\n            }\n            deferred.reject(error);\n        }, ms);\n        this.then(function(value) {\n            clearTimeout(timeoutId);\n            deferred.resolve(value);\n        }, function(exception) {\n            clearTimeout(timeoutId);\n            deferred.reject(exception);\n        }, deferred.notify);\n        return deferred.promise;\n    };\n    /**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */ Q.delay = function(object, timeout) {\n        if (timeout === void 0) {\n            timeout = object;\n            object = void 0;\n        }\n        return Q(object).delay(timeout);\n    };\n    Promise.prototype.delay = function(timeout) {\n        return this.then(function(value) {\n            var deferred = defer();\n            setTimeout(function() {\n                deferred.resolve(value);\n            }, timeout);\n            return deferred.promise;\n        });\n    };\n    /**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */ Q.nfapply = function(callback, args) {\n        return Q(callback).nfapply(args);\n    };\n    Promise.prototype.nfapply = function(args) {\n        var deferred = defer();\n        var nodeArgs = array_slice(args);\n        nodeArgs.push(deferred.makeNodeResolver());\n        this.fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n    /**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */ Q.nfcall = function(callback /*...args*/ ) {\n        var args = array_slice(arguments, 1);\n        return Q(callback).nfapply(args);\n    };\n    Promise.prototype.nfcall = function() {\n        var nodeArgs = array_slice(arguments);\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        this.fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n    /**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */ Q.nfbind = Q.denodeify = function(callback /*...args*/ ) {\n        if (callback === undefined) {\n            throw new Error(\"Q can't wrap an undefined function\");\n        }\n        var baseArgs = array_slice(arguments, 1);\n        return function() {\n            var nodeArgs = baseArgs.concat(array_slice(arguments));\n            var deferred = defer();\n            nodeArgs.push(deferred.makeNodeResolver());\n            Q(callback).fapply(nodeArgs).fail(deferred.reject);\n            return deferred.promise;\n        };\n    };\n    Promise.prototype.nfbind = Promise.prototype.denodeify = function() {\n        var args = array_slice(arguments);\n        args.unshift(this);\n        return Q.denodeify.apply(void 0, args);\n    };\n    Q.nbind = function(callback, thisp /*...args*/ ) {\n        var baseArgs = array_slice(arguments, 2);\n        return function() {\n            var nodeArgs = baseArgs.concat(array_slice(arguments));\n            var deferred = defer();\n            nodeArgs.push(deferred.makeNodeResolver());\n            function bound() {\n                return callback.apply(thisp, arguments);\n            }\n            Q(bound).fapply(nodeArgs).fail(deferred.reject);\n            return deferred.promise;\n        };\n    };\n    Promise.prototype.nbind = function() {\n        var args = array_slice(arguments, 0);\n        args.unshift(this);\n        return Q.nbind.apply(void 0, args);\n    };\n    /**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */ Q.nmapply = Q.npost = function(object, name, args) {\n        return Q(object).npost(name, args);\n    };\n    Promise.prototype.nmapply = Promise.prototype.npost = function(name, args) {\n        var nodeArgs = array_slice(args || []);\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        this.dispatch(\"post\", [\n            name,\n            nodeArgs\n        ]).fail(deferred.reject);\n        return deferred.promise;\n    };\n    /**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */ Q.nsend = Q.nmcall = Q.ninvoke = function(object, name /*...args*/ ) {\n        var nodeArgs = array_slice(arguments, 2);\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(object).dispatch(\"post\", [\n            name,\n            nodeArgs\n        ]).fail(deferred.reject);\n        return deferred.promise;\n    };\n    Promise.prototype.nsend = Promise.prototype.nmcall = Promise.prototype.ninvoke = function(name /*...args*/ ) {\n        var nodeArgs = array_slice(arguments, 1);\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        this.dispatch(\"post\", [\n            name,\n            nodeArgs\n        ]).fail(deferred.reject);\n        return deferred.promise;\n    };\n    /**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */ Q.nodeify = nodeify;\n    function nodeify(object, nodeback) {\n        return Q(object).nodeify(nodeback);\n    }\n    Promise.prototype.nodeify = function(nodeback) {\n        if (nodeback) {\n            this.then(function(value) {\n                Q.nextTick(function() {\n                    nodeback(null, value);\n                });\n            }, function(error) {\n                Q.nextTick(function() {\n                    nodeback(error);\n                });\n            });\n        } else {\n            return this;\n        }\n    };\n    Q.noConflict = function() {\n        throw new Error(\"Q.noConflict only works when Q is used as a global\");\n    };\n    // All code before this point will be filtered from stack traces.\n    var qEndingLine = captureLine();\n    return Q;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UUFBUTtZQUFDeEY7WUFBTXdJO1NBQVMsRUFBRVYsSUFBSSxDQUFDN0csU0FBU2UsTUFBTTtRQUM1RCxPQUFPZixTQUFTaEQsT0FBTztJQUMzQjtJQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNEekYsRUFBRTRRLE9BQU8sR0FBR0E7SUFDWixTQUFTQSxRQUFROUwsTUFBTSxFQUFFK0wsUUFBUTtRQUM3QixPQUFPN1EsRUFBRThFLFFBQVE4TCxPQUFPLENBQUNDO0lBQzdCO0lBRUFqSixRQUFRNUUsU0FBUyxDQUFDNE4sT0FBTyxHQUFHLFNBQVVDLFFBQVE7UUFDMUMsSUFBSUEsVUFBVTtZQUNWLElBQUksQ0FBQ3JHLElBQUksQ0FBQyxTQUFVOUcsS0FBSztnQkFDckIxRCxFQUFFVSxRQUFRLENBQUM7b0JBQ1BtUSxTQUFTLE1BQU1uTjtnQkFDbkI7WUFDSixHQUFHLFNBQVU4QixLQUFLO2dCQUNkeEYsRUFBRVUsUUFBUSxDQUFDO29CQUNQbVEsU0FBU3JMO2dCQUNiO1lBQ0o7UUFDSixPQUFPO1lBQ0gsT0FBTyxJQUFJO1FBQ2Y7SUFDSjtJQUVBeEYsRUFBRUMsVUFBVSxHQUFHO1FBQ1gsTUFBTSxJQUFJQyxNQUFNO0lBQ3BCO0lBRUEsaUVBQWlFO0lBQ2pFLElBQUltSCxjQUFjOUc7SUFFbEIsT0FBT1A7QUFFUCIsInNvdXJjZXMiOlsid2VicGFjazovL2FpZGl0b3IvLi9ub2RlX21vZHVsZXMvcS9xLmpzP2NlMTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdmltOnRzPTQ6c3RzPTQ6c3c9NDpcbi8qIVxuICpcbiAqIENvcHlyaWdodCAyMDA5LTIwMTcgS3JpcyBLb3dhbCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVFxuICogbGljZW5zZSBmb3VuZCBhdCBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EvYmxvYi92MS9MSUNFTlNFXG4gKlxuICogV2l0aCBwYXJ0cyBieSBUeWxlciBDbG9zZVxuICogQ29weXJpZ2h0IDIwMDctMjAwOSBUeWxlciBDbG9zZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBYIGxpY2Vuc2UgZm91bmRcbiAqIGF0IGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UuaHRtbFxuICogRm9ya2VkIGF0IHJlZl9zZW5kLmpzIHZlcnNpb246IDIwMDktMDUtMTFcbiAqXG4gKiBXaXRoIHBhcnRzIGJ5IE1hcmsgTWlsbGVyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTEgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBUaGlzIGZpbGUgd2lsbCBmdW5jdGlvbiBwcm9wZXJseSBhcyBhIDxzY3JpcHQ+IHRhZywgb3IgYSBtb2R1bGVcbiAgICAvLyB1c2luZyBDb21tb25KUyBhbmQgTm9kZUpTIG9yIFJlcXVpcmVKUyBtb2R1bGUgZm9ybWF0cy4gIEluXG4gICAgLy8gQ29tbW9uL05vZGUvUmVxdWlyZUpTLCB0aGUgbW9kdWxlIGV4cG9ydHMgdGhlIFEgQVBJIGFuZCB3aGVuXG4gICAgLy8gZXhlY3V0ZWQgYXMgYSBzaW1wbGUgPHNjcmlwdD4sIGl0IGNyZWF0ZXMgYSBRIGdsb2JhbCBpbnN0ZWFkLlxuXG4gICAgLy8gTW9udGFnZSBSZXF1aXJlXG4gICAgaWYgKHR5cGVvZiBib290c3RyYXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBib290c3RyYXAoXCJwcm9taXNlXCIsIGRlZmluaXRpb24pO1xuXG4gICAgLy8gQ29tbW9uSlNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG5cbiAgICAvLyBSZXF1aXJlSlNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcblxuICAgIC8vIFNFUyAoU2VjdXJlIEVjbWFTY3JpcHQpXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICghc2VzLm9rKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcy5tYWtlUSA9IGRlZmluaXRpb247XG4gICAgICAgIH1cblxuICAgIC8vIDxzY3JpcHQ+XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIFByZWZlciB3aW5kb3cgb3ZlciBzZWxmIGZvciBhZGQtb24gc2NyaXB0cy4gVXNlIHNlbGYgZm9yXG4gICAgICAgIC8vIG5vbi13aW5kb3dlZCBjb250ZXh0cy5cbiAgICAgICAgdmFyIGdsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBzZWxmO1xuXG4gICAgICAgIC8vIEdldCB0aGUgYHdpbmRvd2Agb2JqZWN0LCBzYXZlIHRoZSBwcmV2aW91cyBRIGdsb2JhbFxuICAgICAgICAvLyBhbmQgaW5pdGlhbGl6ZSBRIGFzIGEgZ2xvYmFsLlxuICAgICAgICB2YXIgcHJldmlvdXNRID0gZ2xvYmFsLlE7XG4gICAgICAgIGdsb2JhbC5RID0gZGVmaW5pdGlvbigpO1xuXG4gICAgICAgIC8vIEFkZCBhIG5vQ29uZmxpY3QgZnVuY3Rpb24gc28gUSBjYW4gYmUgcmVtb3ZlZCBmcm9tIHRoZVxuICAgICAgICAvLyBnbG9iYWwgbmFtZXNwYWNlLlxuICAgICAgICBnbG9iYWwuUS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZ2xvYmFsLlEgPSBwcmV2aW91c1E7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgZW52aXJvbm1lbnQgd2FzIG5vdCBhbnRpY2lwYXRlZCBieSBRLiBQbGVhc2UgZmlsZSBhIGJ1Zy5cIik7XG4gICAgfVxuXG59KShmdW5jdGlvbiAoKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGhhc1N0YWNrcyA9IGZhbHNlO1xudHJ5IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbn0gY2F0Y2ggKGUpIHtcbiAgICBoYXNTdGFja3MgPSAhIWUuc3RhY2s7XG59XG5cbi8vIEFsbCBjb2RlIGFmdGVyIHRoaXMgcG9pbnQgd2lsbCBiZSBmaWx0ZXJlZCBmcm9tIHN0YWNrIHRyYWNlcyByZXBvcnRlZFxuLy8gYnkgUS5cbnZhciBxU3RhcnRpbmdMaW5lID0gY2FwdHVyZUxpbmUoKTtcbnZhciBxRmlsZU5hbWU7XG5cbi8vIHNoaW1zXG5cbi8vIHVzZWQgZm9yIGZhbGxiYWNrIGluIFwiYWxsUmVzb2x2ZWRcIlxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcblxuLy8gVXNlIHRoZSBmYXN0ZXN0IHBvc3NpYmxlIG1lYW5zIHRvIGV4ZWN1dGUgYSB0YXNrIGluIGEgZnV0dXJlIHR1cm5cbi8vIG9mIHRoZSBldmVudCBsb29wLlxudmFyIG5leHRUaWNrID0oZnVuY3Rpb24gKCkge1xuICAgIC8vIGxpbmtlZCBsaXN0IG9mIHRhc2tzIChzaW5nbGUsIHdpdGggaGVhZCBub2RlKVxuICAgIHZhciBoZWFkID0ge3Rhc2s6IHZvaWQgMCwgbmV4dDogbnVsbH07XG4gICAgdmFyIHRhaWwgPSBoZWFkO1xuICAgIHZhciBmbHVzaGluZyA9IGZhbHNlO1xuICAgIHZhciByZXF1ZXN0VGljayA9IHZvaWQgMDtcbiAgICB2YXIgaXNOb2RlSlMgPSBmYWxzZTtcbiAgICAvLyBxdWV1ZSBmb3IgbGF0ZSB0YXNrcywgdXNlZCBieSB1bmhhbmRsZWQgcmVqZWN0aW9uIHRyYWNraW5nXG4gICAgdmFyIGxhdGVyUXVldWUgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cbiAgICAgICAgdmFyIHRhc2ssIGRvbWFpbjtcblxuICAgICAgICB3aGlsZSAoaGVhZC5uZXh0KSB7XG4gICAgICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgICAgICAgdGFzayA9IGhlYWQudGFzaztcbiAgICAgICAgICAgIGhlYWQudGFzayA9IHZvaWQgMDtcbiAgICAgICAgICAgIGRvbWFpbiA9IGhlYWQuZG9tYWluO1xuXG4gICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgaGVhZC5kb21haW4gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydW5TaW5nbGUodGFzaywgZG9tYWluKTtcblxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsYXRlclF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGFzayA9IGxhdGVyUXVldWUucG9wKCk7XG4gICAgICAgICAgICBydW5TaW5nbGUodGFzayk7XG4gICAgICAgIH1cbiAgICAgICAgZmx1c2hpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gcnVucyBhIHNpbmdsZSBmdW5jdGlvbiBpbiB0aGUgYXN5bmMgcXVldWVcbiAgICBmdW5jdGlvbiBydW5TaW5nbGUodGFzaywgZG9tYWluKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YXNrKCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gbm9kZSwgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgY29uc2lkZXJlZCBmYXRhbCBlcnJvcnMuXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBzeW5jaHJvbm91c2x5IHRvIGludGVycnVwdCBmbHVzaGluZyFcblxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBjb250aW51YXRpb24gaWYgdGhlIHVuY2F1Z2h0IGV4Y2VwdGlvbiBpcyBzdXBwcmVzc2VkXG4gICAgICAgICAgICAgICAgLy8gbGlzdGVuaW5nIFwidW5jYXVnaHRFeGNlcHRpb25cIiBldmVudHMgKGFzIGRvbWFpbnMgZG9lcykuXG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgaW4gbmV4dCBldmVudCB0byBhdm9pZCB0aWNrIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBicm93c2VycywgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLlxuICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gYXN5bmNocm9ub3VzbHkgdG8gYXZvaWQgc2xvdy1kb3ducy5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0VGljayA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgIHRhaWwgPSB0YWlsLm5leHQgPSB7XG4gICAgICAgICAgICB0YXNrOiB0YXNrLFxuICAgICAgICAgICAgZG9tYWluOiBpc05vZGVKUyAmJiBwcm9jZXNzLmRvbWFpbixcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICByZXF1ZXN0VGljaygpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBwcm9jZXNzLnRvU3RyaW5nKCkgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiICYmIHByb2Nlc3MubmV4dFRpY2spIHtcbiAgICAgICAgLy8gRW5zdXJlIFEgaXMgaW4gYSByZWFsIE5vZGUgZW52aXJvbm1lbnQsIHdpdGggYSBgcHJvY2Vzcy5uZXh0VGlja2AuXG4gICAgICAgIC8vIFRvIHNlZSB0aHJvdWdoIGZha2UgTm9kZSBlbnZpcm9ubWVudHM6XG4gICAgICAgIC8vICogTW9jaGEgdGVzdCBydW5uZXIgLSBleHBvc2VzIGEgYHByb2Nlc3NgIGdsb2JhbCB3aXRob3V0IGEgYG5leHRUaWNrYFxuICAgICAgICAvLyAqIEJyb3dzZXJpZnkgLSBleHBvc2VzIGEgYHByb2Nlc3MubmV4VGlja2AgZnVuY3Rpb24gdGhhdCB1c2VzXG4gICAgICAgIC8vICAgYHNldFRpbWVvdXRgLiBJbiB0aGlzIGNhc2UgYHNldEltbWVkaWF0ZWAgaXMgcHJlZmVycmVkIGJlY2F1c2VcbiAgICAgICAgLy8gICAgaXQgaXMgZmFzdGVyLiBCcm93c2VyaWZ5J3MgYHByb2Nlc3MudG9TdHJpbmcoKWAgeWllbGRzXG4gICAgICAgIC8vICAgXCJbb2JqZWN0IE9iamVjdF1cIiwgd2hpbGUgaW4gYSByZWFsIE5vZGUgZW52aXJvbm1lbnRcbiAgICAgICAgLy8gICBgcHJvY2Vzcy50b1N0cmluZygpYCB5aWVsZHMgXCJbb2JqZWN0IHByb2Nlc3NdXCIuXG4gICAgICAgIGlzTm9kZUpTID0gdHJ1ZTtcblxuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgICAgICB9O1xuXG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gSW4gSUUxMCwgTm9kZS5qcyAwLjkrLCBvciBodHRwczovL2dpdGh1Yi5jb20vTm9ibGVKUy9zZXRJbW1lZGlhdGVcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrID0gc2V0SW1tZWRpYXRlLmJpbmQod2luZG93LCBmbHVzaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZXRJbW1lZGlhdGUoZmx1c2gpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIC8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIC8vIEF0IGxlYXN0IFNhZmFyaSBWZXJzaW9uIDYuMC41ICg4NTM2LjMwLjEpIGludGVybWl0dGVudGx5IGNhbm5vdCBjcmVhdGVcbiAgICAgICAgLy8gd29ya2luZyBtZXNzYWdlIHBvcnRzIHRoZSBmaXJzdCB0aW1lIGEgcGFnZSBsb2Fkcy5cbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0VGljayA9IHJlcXVlc3RQb3J0VGljaztcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gICAgICAgICAgICBmbHVzaCgpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVxdWVzdFBvcnRUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gT3BlcmEgcmVxdWlyZXMgdXMgdG8gcHJvdmlkZSBhIG1lc3NhZ2UgcGF5bG9hZCwgcmVnYXJkbGVzcyBvZlxuICAgICAgICAgICAgLy8gd2hldGhlciB3ZSB1c2UgaXQuXG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgICB9O1xuICAgICAgICByZXF1ZXN0VGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgcmVxdWVzdFBvcnRUaWNrKCk7XG4gICAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbGQgYnJvd3NlcnNcbiAgICAgICAgcmVxdWVzdFRpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gcnVucyBhIHRhc2sgYWZ0ZXIgYWxsIG90aGVyIHRhc2tzIGhhdmUgYmVlbiBydW5cbiAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgdW5oYW5kbGVkIHJlamVjdGlvbiB0cmFja2luZyB0aGF0IG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIGFsbCBgdGhlbmBkIHRhc2tzIGhhdmUgYmVlbiBydW4uXG4gICAgbmV4dFRpY2sucnVuQWZ0ZXIgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICBsYXRlclF1ZXVlLnB1c2godGFzayk7XG4gICAgICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RUaWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBuZXh0VGljaztcbn0pKCk7XG5cbi8vIEF0dGVtcHQgdG8gbWFrZSBnZW5lcmljcyBzYWZlIGluIHRoZSBmYWNlIG9mIGRvd25zdHJlYW1cbi8vIG1vZGlmaWNhdGlvbnMuXG4vLyBUaGVyZSBpcyBubyBzaXR1YXRpb24gd2hlcmUgdGhpcyBpcyBuZWNlc3NhcnkuXG4vLyBJZiB5b3UgbmVlZCBhIHNlY3VyaXR5IGd1YXJhbnRlZSwgdGhlc2UgcHJpbW9yZGlhbHMgbmVlZCB0byBiZVxuLy8gZGVlcGx5IGZyb3plbiBhbnl3YXksIGFuZCBpZiB5b3UgZG9u4oCZdCBuZWVkIGEgc2VjdXJpdHkgZ3VhcmFudGVlLFxuLy8gdGhpcyBpcyBqdXN0IHBsYWluIHBhcmFub2lkLlxuLy8gSG93ZXZlciwgdGhpcyAqKm1pZ2h0KiogaGF2ZSB0aGUgbmljZSBzaWRlLWVmZmVjdCBvZiByZWR1Y2luZyB0aGUgc2l6ZSBvZlxuLy8gdGhlIG1pbmlmaWVkIGNvZGUgYnkgcmVkdWNpbmcgeC5jYWxsKCkgdG8gbWVyZWx5IHgoKVxuLy8gU2VlIE1hcmsgTWlsbGVy4oCZcyBleHBsYW5hdGlvbiBvZiB3aGF0IHRoaXMgZG9lcy5cbi8vIGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWNvbnZlbnRpb25zOnNhZmVfbWV0YV9wcm9ncmFtbWluZ1xudmFyIGNhbGwgPSBGdW5jdGlvbi5jYWxsO1xuZnVuY3Rpb24gdW5jdXJyeVRoaXMoZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjYWxsLmFwcGx5KGYsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cbi8vIFRoaXMgaXMgZXF1aXZhbGVudCwgYnV0IHNsb3dlcjpcbi8vIHVuY3VycnlUaGlzID0gRnVuY3Rpb25fYmluZC5iaW5kKEZ1bmN0aW9uX2JpbmQuY2FsbCk7XG4vLyBodHRwOi8vanNwZXJmLmNvbS91bmN1cnJ5dGhpc1xuXG52YXIgYXJyYXlfc2xpY2UgPSB1bmN1cnJ5VGhpcyhBcnJheS5wcm90b3R5cGUuc2xpY2UpO1xuXG52YXIgYXJyYXlfcmVkdWNlID0gdW5jdXJyeVRoaXMoXG4gICAgQXJyYXkucHJvdG90eXBlLnJlZHVjZSB8fCBmdW5jdGlvbiAoY2FsbGJhY2ssIGJhc2lzKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgLy8gY29uY2VybmluZyB0aGUgaW5pdGlhbCB2YWx1ZSwgaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gc2VlayB0byB0aGUgZmlyc3QgdmFsdWUgaW4gdGhlIGFycmF5LCBhY2NvdW50aW5nXG4gICAgICAgICAgICAvLyBmb3IgdGhlIHBvc3NpYmlsaXR5IHRoYXQgaXMgaXMgYSBzcGFyc2UgYXJyYXlcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggaW4gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBiYXNpcyA9IHRoaXNbaW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKytpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZHVjZVxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIHRoZSBwb3NzaWJpbGl0eSB0aGF0IHRoZSBhcnJheSBpcyBzcGFyc2VcbiAgICAgICAgICAgIGlmIChpbmRleCBpbiB0aGlzKSB7XG4gICAgICAgICAgICAgICAgYmFzaXMgPSBjYWxsYmFjayhiYXNpcywgdGhpc1tpbmRleF0sIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzaXM7XG4gICAgfVxuKTtcblxudmFyIGFycmF5X2luZGV4T2YgPSB1bmN1cnJ5VGhpcyhcbiAgICBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gbm90IGEgdmVyeSBnb29kIHNoaW0sIGJ1dCBnb29kIGVub3VnaCBmb3Igb3VyIG9uZSB1c2Ugb2YgaXRcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuKTtcblxudmFyIGFycmF5X21hcCA9IHVuY3VycnlUaGlzKFxuICAgIEFycmF5LnByb3RvdHlwZS5tYXAgfHwgZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzcCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb2xsZWN0ID0gW107XG4gICAgICAgIGFycmF5X3JlZHVjZShzZWxmLCBmdW5jdGlvbiAodW5kZWZpbmVkLCB2YWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIGNvbGxlY3QucHVzaChjYWxsYmFjay5jYWxsKHRoaXNwLCB2YWx1ZSwgaW5kZXgsIHNlbGYpKTtcbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Q7XG4gICAgfVxuKTtcblxudmFyIG9iamVjdF9jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90b3R5cGUpIHtcbiAgICBmdW5jdGlvbiBUeXBlKCkgeyB9XG4gICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgcmV0dXJuIG5ldyBUeXBlKCk7XG59O1xuXG52YXIgb2JqZWN0X2RlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIHByb3AsIGRlc2NyaXB0b3IpIHtcbiAgICBvYmpbcHJvcF0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG52YXIgb2JqZWN0X2hhc093blByb3BlcnR5ID0gdW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbnZhciBvYmplY3Rfa2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKG9iamVjdF9oYXNPd25Qcm9wZXJ0eShvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufTtcblxudmFyIG9iamVjdF90b1N0cmluZyA9IHVuY3VycnlUaGlzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpO1xuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gT2JqZWN0KHZhbHVlKTtcbn1cblxuLy8gZ2VuZXJhdG9yIHJlbGF0ZWQgc2hpbXNcblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGZ1bmN0aW9uIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluIFNwaWRlck1vbmtleS5cbmZ1bmN0aW9uIGlzU3RvcEl0ZXJhdGlvbihleGNlcHRpb24pIHtcbiAgICByZXR1cm4gKFxuICAgICAgICBvYmplY3RfdG9TdHJpbmcoZXhjZXB0aW9uKSA9PT0gXCJbb2JqZWN0IFN0b3BJdGVyYXRpb25dXCIgfHxcbiAgICAgICAgZXhjZXB0aW9uIGluc3RhbmNlb2YgUVJldHVyblZhbHVlXG4gICAgKTtcbn1cblxuLy8gRklYTUU6IFJlbW92ZSB0aGlzIGhlbHBlciBhbmQgUS5yZXR1cm4gb25jZSBFUzYgZ2VuZXJhdG9ycyBhcmUgaW5cbi8vIFNwaWRlck1vbmtleS5cbnZhciBRUmV0dXJuVmFsdWU7XG5pZiAodHlwZW9mIFJldHVyblZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgUVJldHVyblZhbHVlID0gUmV0dXJuVmFsdWU7XG59IGVsc2Uge1xuICAgIFFSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfTtcbn1cblxuLy8gbG9uZyBzdGFjayB0cmFjZXNcblxudmFyIFNUQUNLX0pVTVBfU0VQQVJBVE9SID0gXCJGcm9tIHByZXZpb3VzIGV2ZW50OlwiO1xuXG5mdW5jdGlvbiBtYWtlU3RhY2tUcmFjZUxvbmcoZXJyb3IsIHByb21pc2UpIHtcbiAgICAvLyBJZiBwb3NzaWJsZSwgdHJhbnNmb3JtIHRoZSBlcnJvciBzdGFjayB0cmFjZSBieSByZW1vdmluZyBOb2RlIGFuZCBRXG4gICAgLy8gY3J1ZnQsIHRoZW4gY29uY2F0ZW5hdGluZyB3aXRoIHRoZSBzdGFjayB0cmFjZSBvZiBgcHJvbWlzZWAuIFNlZSAjNTcuXG4gICAgaWYgKGhhc1N0YWNrcyAmJlxuICAgICAgICBwcm9taXNlLnN0YWNrICYmXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBlcnJvciAhPT0gbnVsbCAmJlxuICAgICAgICBlcnJvci5zdGFja1xuICAgICkge1xuICAgICAgICB2YXIgc3RhY2tzID0gW107XG4gICAgICAgIGZvciAodmFyIHAgPSBwcm9taXNlOyAhIXA7IHAgPSBwLnNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHAuc3RhY2sgJiYgKCFlcnJvci5fX21pbmltdW1TdGFja0NvdW50ZXJfXyB8fCBlcnJvci5fX21pbmltdW1TdGFja0NvdW50ZXJfXyA+IHAuc3RhY2tDb3VudGVyKSkge1xuICAgICAgICAgICAgICAgIG9iamVjdF9kZWZpbmVQcm9wZXJ0eShlcnJvciwgXCJfX21pbmltdW1TdGFja0NvdW50ZXJfX1wiLCB7dmFsdWU6IHAuc3RhY2tDb3VudGVyLCBjb25maWd1cmFibGU6IHRydWV9KTtcbiAgICAgICAgICAgICAgICBzdGFja3MudW5zaGlmdChwLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGFja3MudW5zaGlmdChlcnJvci5zdGFjayk7XG5cbiAgICAgICAgdmFyIGNvbmNhdGVkU3RhY2tzID0gc3RhY2tzLmpvaW4oXCJcXG5cIiArIFNUQUNLX0pVTVBfU0VQQVJBVE9SICsgXCJcXG5cIik7XG4gICAgICAgIHZhciBzdGFjayA9IGZpbHRlclN0YWNrU3RyaW5nKGNvbmNhdGVkU3RhY2tzKTtcbiAgICAgICAgb2JqZWN0X2RlZmluZVByb3BlcnR5KGVycm9yLCBcInN0YWNrXCIsIHt2YWx1ZTogc3RhY2ssIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZmlsdGVyU3RhY2tTdHJpbmcoc3RhY2tTdHJpbmcpIHtcbiAgICB2YXIgbGluZXMgPSBzdGFja1N0cmluZy5zcGxpdChcIlxcblwiKTtcbiAgICB2YXIgZGVzaXJlZExpbmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuXG4gICAgICAgIGlmICghaXNJbnRlcm5hbEZyYW1lKGxpbmUpICYmICFpc05vZGVGcmFtZShsaW5lKSAmJiBsaW5lKSB7XG4gICAgICAgICAgICBkZXNpcmVkTGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVzaXJlZExpbmVzLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZUZyYW1lKHN0YWNrTGluZSkge1xuICAgIHJldHVybiBzdGFja0xpbmUuaW5kZXhPZihcIihtb2R1bGUuanM6XCIpICE9PSAtMSB8fFxuICAgICAgICAgICBzdGFja0xpbmUuaW5kZXhPZihcIihub2RlLmpzOlwiKSAhPT0gLTE7XG59XG5cbmZ1bmN0aW9uIGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpIHtcbiAgICAvLyBOYW1lZCBmdW5jdGlvbnM6IFwiYXQgZnVuY3Rpb25OYW1lIChmaWxlbmFtZTpsaW5lTnVtYmVyOmNvbHVtbk51bWJlcilcIlxuICAgIC8vIEluIElFMTAgZnVuY3Rpb24gbmFtZSBjYW4gaGF2ZSBzcGFjZXMgKFwiQW5vbnltb3VzIGZ1bmN0aW9uXCIpIE9fb1xuICAgIHZhciBhdHRlbXB0MSA9IC9hdCAuKyBcXCgoLispOihcXGQrKTooPzpcXGQrKVxcKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDEpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0MVsxXSwgTnVtYmVyKGF0dGVtcHQxWzJdKV07XG4gICAgfVxuXG4gICAgLy8gQW5vbnltb3VzIGZ1bmN0aW9uczogXCJhdCBmaWxlbmFtZTpsaW5lTnVtYmVyOmNvbHVtbk51bWJlclwiXG4gICAgdmFyIGF0dGVtcHQyID0gL2F0IChbXiBdKyk6KFxcZCspOig/OlxcZCspJC8uZXhlYyhzdGFja0xpbmUpO1xuICAgIGlmIChhdHRlbXB0Mikge1xuICAgICAgICByZXR1cm4gW2F0dGVtcHQyWzFdLCBOdW1iZXIoYXR0ZW1wdDJbMl0pXTtcbiAgICB9XG5cbiAgICAvLyBGaXJlZm94IHN0eWxlOiBcImZ1bmN0aW9uQGZpbGVuYW1lOmxpbmVOdW1iZXIgb3IgQGZpbGVuYW1lOmxpbmVOdW1iZXJcIlxuICAgIHZhciBhdHRlbXB0MyA9IC8uKkAoLispOihcXGQrKSQvLmV4ZWMoc3RhY2tMaW5lKTtcbiAgICBpZiAoYXR0ZW1wdDMpIHtcbiAgICAgICAgcmV0dXJuIFthdHRlbXB0M1sxXSwgTnVtYmVyKGF0dGVtcHQzWzJdKV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0ludGVybmFsRnJhbWUoc3RhY2tMaW5lKSB7XG4gICAgdmFyIGZpbGVOYW1lQW5kTGluZU51bWJlciA9IGdldEZpbGVOYW1lQW5kTGluZU51bWJlcihzdGFja0xpbmUpO1xuXG4gICAgaWYgKCFmaWxlTmFtZUFuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaWxlTmFtZSA9IGZpbGVOYW1lQW5kTGluZU51bWJlclswXTtcbiAgICB2YXIgbGluZU51bWJlciA9IGZpbGVOYW1lQW5kTGluZU51bWJlclsxXTtcblxuICAgIHJldHVybiBmaWxlTmFtZSA9PT0gcUZpbGVOYW1lICYmXG4gICAgICAgIGxpbmVOdW1iZXIgPj0gcVN0YXJ0aW5nTGluZSAmJlxuICAgICAgICBsaW5lTnVtYmVyIDw9IHFFbmRpbmdMaW5lO1xufVxuXG4vLyBkaXNjb3ZlciBvd24gZmlsZSBuYW1lIGFuZCBsaW5lIG51bWJlciByYW5nZSBmb3IgZmlsdGVyaW5nIHN0YWNrXG4vLyB0cmFjZXNcbmZ1bmN0aW9uIGNhcHR1cmVMaW5lKCkge1xuICAgIGlmICghaGFzU3RhY2tzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IGUuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgIHZhciBmaXJzdExpbmUgPSBsaW5lc1swXS5pbmRleE9mKFwiQFwiKSA+IDAgPyBsaW5lc1sxXSA6IGxpbmVzWzJdO1xuICAgICAgICB2YXIgZmlsZU5hbWVBbmRMaW5lTnVtYmVyID0gZ2V0RmlsZU5hbWVBbmRMaW5lTnVtYmVyKGZpcnN0TGluZSk7XG4gICAgICAgIGlmICghZmlsZU5hbWVBbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBxRmlsZU5hbWUgPSBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMF07XG4gICAgICAgIHJldHVybiBmaWxlTmFtZUFuZExpbmVOdW1iZXJbMV07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZXByZWNhdGUoY2FsbGJhY2ssIG5hbWUsIGFsdGVybmF0aXZlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZS53YXJuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihuYW1lICsgXCIgaXMgZGVwcmVjYXRlZCwgdXNlIFwiICsgYWx0ZXJuYXRpdmUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIFwiIGluc3RlYWQuXCIsIG5ldyBFcnJvcihcIlwiKS5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KGNhbGxiYWNrLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8vIGVuZCBvZiBzaGltc1xuLy8gYmVnaW5uaW5nIG9mIHJlYWwgd29ya1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBwcm9taXNlIGZvciBhbiBpbW1lZGlhdGUgcmVmZXJlbmNlLCBwYXNzZXMgcHJvbWlzZXMgdGhyb3VnaCwgb3JcbiAqIGNvZXJjZXMgcHJvbWlzZXMgZnJvbSBkaWZmZXJlbnQgc3lzdGVtcy5cbiAqIEBwYXJhbSB2YWx1ZSBpbW1lZGlhdGUgcmVmZXJlbmNlIG9yIHByb21pc2VcbiAqL1xuZnVuY3Rpb24gUSh2YWx1ZSkge1xuICAgIC8vIElmIHRoZSBvYmplY3QgaXMgYWxyZWFkeSBhIFByb21pc2UsIHJldHVybiBpdCBkaXJlY3RseS4gIFRoaXMgZW5hYmxlc1xuICAgIC8vIHRoZSByZXNvbHZlIGZ1bmN0aW9uIHRvIGJvdGggYmUgdXNlZCB0byBjcmVhdGVkIHJlZmVyZW5jZXMgZnJvbSBvYmplY3RzLFxuICAgIC8vIGJ1dCB0byB0b2xlcmFibHkgY29lcmNlIG5vbi1wcm9taXNlcyB0byBwcm9taXNlcy5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBhc3NpbWlsYXRlIHRoZW5hYmxlc1xuICAgIGlmIChpc1Byb21pc2VBbGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvZXJjZSh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGwodmFsdWUpO1xuICAgIH1cbn1cblEucmVzb2x2ZSA9IFE7XG5cbi8qKlxuICogUGVyZm9ybXMgYSB0YXNrIGluIGEgZnV0dXJlIHR1cm4gb2YgdGhlIGV2ZW50IGxvb3AuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0YXNrXG4gKi9cblEubmV4dFRpY2sgPSBuZXh0VGljaztcblxuLyoqXG4gKiBDb250cm9scyB3aGV0aGVyIG9yIG5vdCBsb25nIHN0YWNrIHRyYWNlcyB3aWxsIGJlIG9uXG4gKi9cblEubG9uZ1N0YWNrU3VwcG9ydCA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBjb3VudGVyIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBzdG9wcGluZyBwb2ludCBmb3IgYnVpbGRpbmdcbiAqIGxvbmcgc3RhY2sgdHJhY2VzLiBJbiBtYWtlU3RhY2tUcmFjZUxvbmcgd2Ugd2FsayBiYWNrd2FyZHMgdGhyb3VnaFxuICogdGhlIGxpbmtlZCBsaXN0IG9mIHByb21pc2VzLCBvbmx5IHN0YWNrcyB3aGljaCB3ZXJlIGNyZWF0ZWQgYmVmb3JlXG4gKiB0aGUgcmVqZWN0aW9uIGFyZSBjb25jYXRlbmF0ZWQuXG4gKi9cbnZhciBsb25nU3RhY2tDb3VudGVyID0gMTtcblxuLy8gZW5hYmxlIGxvbmcgc3RhY2tzIGlmIFFfREVCVUcgaXMgc2V0XG5pZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgcHJvY2VzcyAmJiBwcm9jZXNzLmVudiAmJiBwcm9jZXNzLmVudi5RX0RFQlVHKSB7XG4gICAgUS5sb25nU3RhY2tTdXBwb3J0ID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEge3Byb21pc2UsIHJlc29sdmUsIHJlamVjdH0gb2JqZWN0LlxuICpcbiAqIGByZXNvbHZlYCBpcyBhIGNhbGxiYWNrIHRvIGludm9rZSB3aXRoIGEgbW9yZSByZXNvbHZlZCB2YWx1ZSBmb3IgdGhlXG4gKiBwcm9taXNlLiBUbyBmdWxmaWxsIHRoZSBwcm9taXNlLCBpbnZva2UgYHJlc29sdmVgIHdpdGggYW55IHZhbHVlIHRoYXQgaXNcbiAqIG5vdCBhIHRoZW5hYmxlLiBUbyByZWplY3QgdGhlIHByb21pc2UsIGludm9rZSBgcmVzb2x2ZWAgd2l0aCBhIHJlamVjdGVkXG4gKiB0aGVuYWJsZSwgb3IgaW52b2tlIGByZWplY3RgIHdpdGggdGhlIHJlYXNvbiBkaXJlY3RseS4gVG8gcmVzb2x2ZSB0aGVcbiAqIHByb21pc2UgdG8gYW5vdGhlciB0aGVuYWJsZSwgdGh1cyBwdXR0aW5nIGl0IGluIHRoZSBzYW1lIHN0YXRlLCBpbnZva2VcbiAqIGByZXNvbHZlYCB3aXRoIHRoYXQgb3RoZXIgdGhlbmFibGUuXG4gKi9cblEuZGVmZXIgPSBkZWZlcjtcbmZ1bmN0aW9uIGRlZmVyKCkge1xuICAgIC8vIGlmIFwibWVzc2FnZXNcIiBpcyBhbiBcIkFycmF5XCIsIHRoYXQgaW5kaWNhdGVzIHRoYXQgdGhlIHByb21pc2UgaGFzIG5vdCB5ZXRcbiAgICAvLyBiZWVuIHJlc29sdmVkLiAgSWYgaXQgaXMgXCJ1bmRlZmluZWRcIiwgaXQgaGFzIGJlZW4gcmVzb2x2ZWQuICBFYWNoXG4gICAgLy8gZWxlbWVudCBvZiB0aGUgbWVzc2FnZXMgYXJyYXkgaXMgaXRzZWxmIGFuIGFycmF5IG9mIGNvbXBsZXRlIGFyZ3VtZW50cyB0b1xuICAgIC8vIGZvcndhcmQgdG8gdGhlIHJlc29sdmVkIHByb21pc2UuICBXZSBjb2VyY2UgdGhlIHJlc29sdXRpb24gdmFsdWUgdG8gYVxuICAgIC8vIHByb21pc2UgdXNpbmcgdGhlIGByZXNvbHZlYCBmdW5jdGlvbiBiZWNhdXNlIGl0IGhhbmRsZXMgYm90aCBmdWxseVxuICAgIC8vIG5vbi10aGVuYWJsZSB2YWx1ZXMgYW5kIG90aGVyIHRoZW5hYmxlcyBncmFjZWZ1bGx5LlxuICAgIHZhciBtZXNzYWdlcyA9IFtdLCBwcm9ncmVzc0xpc3RlbmVycyA9IFtdLCByZXNvbHZlZFByb21pc2U7XG5cbiAgICB2YXIgZGVmZXJyZWQgPSBvYmplY3RfY3JlYXRlKGRlZmVyLnByb3RvdHlwZSk7XG4gICAgdmFyIHByb21pc2UgPSBvYmplY3RfY3JlYXRlKFByb21pc2UucHJvdG90eXBlKTtcblxuICAgIHByb21pc2UucHJvbWlzZURpc3BhdGNoID0gZnVuY3Rpb24gKHJlc29sdmUsIG9wLCBvcGVyYW5kcykge1xuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgbWVzc2FnZXMucHVzaChhcmdzKTtcbiAgICAgICAgICAgIGlmIChvcCA9PT0gXCJ3aGVuXCIgJiYgb3BlcmFuZHNbMV0pIHsgLy8gcHJvZ3Jlc3Mgb3BlcmFuZFxuICAgICAgICAgICAgICAgIHByb2dyZXNzTGlzdGVuZXJzLnB1c2gob3BlcmFuZHNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnByb21pc2VEaXNwYXRjaC5hcHBseShyZXNvbHZlZFByb21pc2UsIGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gWFhYIGRlcHJlY2F0ZWRcbiAgICBwcm9taXNlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChtZXNzYWdlcykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5lYXJlclZhbHVlID0gbmVhcmVyKHJlc29sdmVkUHJvbWlzZSk7XG4gICAgICAgIGlmIChpc1Byb21pc2UobmVhcmVyVmFsdWUpKSB7XG4gICAgICAgICAgICByZXNvbHZlZFByb21pc2UgPSBuZWFyZXJWYWx1ZTsgLy8gc2hvcnRlbiBjaGFpblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZWFyZXJWYWx1ZTtcbiAgICB9O1xuXG4gICAgcHJvbWlzZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdGU6IFwicGVuZGluZ1wiIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkUHJvbWlzZS5pbnNwZWN0KCk7XG4gICAgfTtcblxuICAgIGlmIChRLmxvbmdTdGFja1N1cHBvcnQgJiYgaGFzU3RhY2tzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTk9URTogZG9uJ3QgdHJ5IHRvIHVzZSBgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2VgIG9yIHRyYW5zZmVyIHRoZVxuICAgICAgICAgICAgLy8gYWNjZXNzb3IgYXJvdW5kOyB0aGF0IGNhdXNlcyBtZW1vcnkgbGVha3MgYXMgcGVyIEdILTExMS4gSnVzdFxuICAgICAgICAgICAgLy8gcmVpZnkgdGhlIHN0YWNrIHRyYWNlIGFzIGEgc3RyaW5nIEFTQVAuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQXQgdGhlIHNhbWUgdGltZSwgY3V0IG9mZiB0aGUgZmlyc3QgbGluZTsgaXQncyBhbHdheXMganVzdFxuICAgICAgICAgICAgLy8gXCJbb2JqZWN0IFByb21pc2VdXFxuXCIsIGFzIHBlciB0aGUgYHRvU3RyaW5nYC5cbiAgICAgICAgICAgIHByb21pc2Uuc3RhY2sgPSBlLnN0YWNrLnN1YnN0cmluZyhlLnN0YWNrLmluZGV4T2YoXCJcXG5cIikgKyAxKTtcbiAgICAgICAgICAgIHByb21pc2Uuc3RhY2tDb3VudGVyID0gbG9uZ1N0YWNrQ291bnRlcisrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTk9URTogd2UgZG8gdGhlIGNoZWNrcyBmb3IgYHJlc29sdmVkUHJvbWlzZWAgaW4gZWFjaCBtZXRob2QsIGluc3RlYWQgb2ZcbiAgICAvLyBjb25zb2xpZGF0aW5nIHRoZW0gaW50byBgYmVjb21lYCwgc2luY2Ugb3RoZXJ3aXNlIHdlJ2QgY3JlYXRlIG5ld1xuICAgIC8vIHByb21pc2VzIHdpdGggdGhlIGxpbmVzIGBiZWNvbWUod2hhdGV2ZXIodmFsdWUpKWAuIFNlZSBlLmcuIEdILTI1Mi5cblxuICAgIGZ1bmN0aW9uIGJlY29tZShuZXdQcm9taXNlKSB7XG4gICAgICAgIHJlc29sdmVkUHJvbWlzZSA9IG5ld1Byb21pc2U7XG5cbiAgICAgICAgaWYgKFEubG9uZ1N0YWNrU3VwcG9ydCAmJiBoYXNTdGFja3MpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgaG9sZCBhIHJlZmVyZW5jZSB0byB0aGUgbmV3IHByb21pc2UgaWYgbG9uZyBzdGFja3NcbiAgICAgICAgICAgIC8vIGFyZSBlbmFibGVkIHRvIHJlZHVjZSBtZW1vcnkgdXNhZ2VcbiAgICAgICAgICAgIHByb21pc2Uuc291cmNlID0gbmV3UHJvbWlzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5X3JlZHVjZShtZXNzYWdlcywgZnVuY3Rpb24gKHVuZGVmaW5lZCwgbWVzc2FnZSkge1xuICAgICAgICAgICAgUS5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvbWlzZS5wcm9taXNlRGlzcGF0Y2guYXBwbHkobmV3UHJvbWlzZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgdm9pZCAwKTtcblxuICAgICAgICBtZXNzYWdlcyA9IHZvaWQgMDtcbiAgICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcnMgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZGVmZXJyZWQucHJvbWlzZSA9IHByb21pc2U7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBiZWNvbWUoUSh2YWx1ZSkpO1xuICAgIH07XG5cbiAgICBkZWZlcnJlZC5mdWxmaWxsID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShmdWxmaWxsKHZhbHVlKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmIChyZXNvbHZlZFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlY29tZShyZWplY3QocmVhc29uKSk7XG4gICAgfTtcbiAgICBkZWZlcnJlZC5ub3RpZnkgPSBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgaWYgKHJlc29sdmVkUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb2dyZXNzTGlzdGVuZXJzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9ncmVzc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0xpc3RlbmVyKHByb2dyZXNzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB2b2lkIDApO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmZXJyZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIE5vZGUtc3R5bGUgY2FsbGJhY2sgdGhhdCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0IHRoZSBkZWZlcnJlZFxuICogcHJvbWlzZS5cbiAqIEByZXR1cm5zIGEgbm9kZWJhY2tcbiAqL1xuZGVmZXIucHJvdG90eXBlLm1ha2VOb2RlUmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyb3IsIHZhbHVlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUoYXJyYXlfc2xpY2UoYXJndW1lbnRzLCAxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHJlc29sdmVyIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgbm90aGluZyBhbmQgYWNjZXB0c1xuICogdGhlIHJlc29sdmUsIHJlamVjdCwgYW5kIG5vdGlmeSBmdW5jdGlvbnMgZm9yIGEgZGVmZXJyZWQuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgdGhhdCBtYXkgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgZ2l2ZW4gcmVzb2x2ZSBhbmQgcmVqZWN0XG4gKiBmdW5jdGlvbnMsIG9yIHJlamVjdGVkIGJ5IGEgdGhyb3duIGV4Y2VwdGlvbiBpbiByZXNvbHZlclxuICovXG5RLlByb21pc2UgPSBwcm9taXNlOyAvLyBFUzZcblEucHJvbWlzZSA9IHByb21pc2U7XG5mdW5jdGlvbiBwcm9taXNlKHJlc29sdmVyKSB7XG4gICAgaWYgKHR5cGVvZiByZXNvbHZlciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgIH1cbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIHRyeSB7XG4gICAgICAgIHJlc29sdmVyKGRlZmVycmVkLnJlc29sdmUsIGRlZmVycmVkLnJlamVjdCwgZGVmZXJyZWQubm90aWZ5KTtcbiAgICB9IGNhdGNoIChyZWFzb24pIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufVxuXG5wcm9taXNlLnJhY2UgPSByYWNlOyAvLyBFUzZcbnByb21pc2UuYWxsID0gYWxsOyAvLyBFUzZcbnByb21pc2UucmVqZWN0ID0gcmVqZWN0OyAvLyBFUzZcbnByb21pc2UucmVzb2x2ZSA9IFE7IC8vIEVTNlxuXG4vLyBYWFggZXhwZXJpbWVudGFsLiAgVGhpcyBtZXRob2QgaXMgYSB3YXkgdG8gZGVub3RlIHRoYXQgYSBsb2NhbCB2YWx1ZSBpc1xuLy8gc2VyaWFsaXphYmxlIGFuZCBzaG91bGQgYmUgaW1tZWRpYXRlbHkgZGlzcGF0Y2hlZCB0byBhIHJlbW90ZSB1cG9uIHJlcXVlc3QsXG4vLyBpbnN0ZWFkIG9mIHBhc3NpbmcgYSByZWZlcmVuY2UuXG5RLnBhc3NCeUNvcHkgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgLy9mcmVlemUob2JqZWN0KTtcbiAgICAvL3Bhc3NCeUNvcGllcy5zZXQob2JqZWN0LCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUucGFzc0J5Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvL2ZyZWV6ZShvYmplY3QpO1xuICAgIC8vcGFzc0J5Q29waWVzLnNldChvYmplY3QsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJZiB0d28gcHJvbWlzZXMgZXZlbnR1YWxseSBmdWxmaWxsIHRvIHRoZSBzYW1lIHZhbHVlLCBwcm9taXNlcyB0aGF0IHZhbHVlLFxuICogYnV0IG90aGVyd2lzZSByZWplY3RzLlxuICogQHBhcmFtIHgge0FueSp9XG4gKiBAcGFyYW0geSB7QW55Kn1cbiAqIEByZXR1cm5zIHtBbnkqfSBhIHByb21pc2UgZm9yIHggYW5kIHkgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGJ1dCBhIHJlamVjdGlvblxuICogb3RoZXJ3aXNlLlxuICpcbiAqL1xuUS5qb2luID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gUSh4KS5qb2luKHkpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uICh0aGF0KSB7XG4gICAgcmV0dXJuIFEoW3RoaXMsIHRoYXRdKS5zcHJlYWQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgaWYgKHggPT09IHkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFwiPT09XCIgc2hvdWxkIGJlIE9iamVjdC5pcyBvciBlcXVpdlxuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRIGNhbid0IGpvaW46IG5vdCB0aGUgc2FtZTogXCIgKyB4ICsgXCIgXCIgKyB5KTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIGZpcnN0IG9mIGFuIGFycmF5IG9mIHByb21pc2VzIHRvIGJlY29tZSBzZXR0bGVkLlxuICogQHBhcmFtIGFuc3dlcnMge0FycmF5W0FueSpdfSBwcm9taXNlcyB0byByYWNlXG4gKiBAcmV0dXJucyB7QW55Kn0gdGhlIGZpcnN0IHByb21pc2UgdG8gYmUgc2V0dGxlZFxuICovXG5RLnJhY2UgPSByYWNlO1xuZnVuY3Rpb24gcmFjZShhbnN3ZXJQcykge1xuICAgIHJldHVybiBwcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHRoaXMgb25jZSB3ZSBjYW4gYXNzdW1lIGF0IGxlYXN0IEVTNVxuICAgICAgICAvLyBhbnN3ZXJQcy5mb3JFYWNoKGZ1bmN0aW9uIChhbnN3ZXJQKSB7XG4gICAgICAgIC8vICAgICBRKGFuc3dlclApLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIC8vIFVzZSB0aGlzIGluIHRoZSBtZWFudGltZVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYW5zd2VyUHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIFEoYW5zd2VyUHNbaV0pLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5yYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4oUS5yYWNlKTtcbn07XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIFByb21pc2Ugd2l0aCBhIHByb21pc2UgZGVzY3JpcHRvciBvYmplY3QgYW5kIG9wdGlvbmFsIGZhbGxiYWNrXG4gKiBmdW5jdGlvbi4gIFRoZSBkZXNjcmlwdG9yIGNvbnRhaW5zIG1ldGhvZHMgbGlrZSB3aGVuKHJlamVjdGVkKSwgZ2V0KG5hbWUpLFxuICogc2V0KG5hbWUsIHZhbHVlKSwgcG9zdChuYW1lLCBhcmdzKSwgYW5kIGRlbGV0ZShuYW1lKSwgd2hpY2ggYWxsXG4gKiByZXR1cm4gZWl0aGVyIGEgdmFsdWUsIGEgcHJvbWlzZSBmb3IgYSB2YWx1ZSwgb3IgYSByZWplY3Rpb24uICBUaGUgZmFsbGJhY2tcbiAqIGFjY2VwdHMgdGhlIG9wZXJhdGlvbiBuYW1lLCBhIHJlc29sdmVyLCBhbmQgYW55IGZ1cnRoZXIgYXJndW1lbnRzIHRoYXQgd291bGRcbiAqIGhhdmUgYmVlbiBmb3J3YXJkZWQgdG8gdGhlIGFwcHJvcHJpYXRlIG1ldGhvZCBhYm92ZSBoYWQgYSBtZXRob2QgYmVlblxuICogcHJvdmlkZWQgd2l0aCB0aGUgcHJvcGVyIG5hbWUuICBUaGUgQVBJIG1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgdGhlIG5hdHVyZVxuICogb2YgdGhlIHJldHVybmVkIG9iamVjdCwgYXBhcnQgZnJvbSB0aGF0IGl0IGlzIHVzYWJsZSB3aGVyZWV2ZXIgcHJvbWlzZXMgYXJlXG4gKiBib3VnaHQgYW5kIHNvbGQuXG4gKi9cblEubWFrZVByb21pc2UgPSBQcm9taXNlO1xuZnVuY3Rpb24gUHJvbWlzZShkZXNjcmlwdG9yLCBmYWxsYmFjaywgaW5zcGVjdCkge1xuICAgIGlmIChmYWxsYmFjayA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGZhbGxiYWNrID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlByb21pc2UgZG9lcyBub3Qgc3VwcG9ydCBvcGVyYXRpb246IFwiICsgb3BcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoaW5zcGVjdCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4ge3N0YXRlOiBcInVua25vd25cIn07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2UgPSBvYmplY3RfY3JlYXRlKFByb21pc2UucHJvdG90eXBlKTtcblxuICAgIHByb21pc2UucHJvbWlzZURpc3BhdGNoID0gZnVuY3Rpb24gKHJlc29sdmUsIG9wLCBhcmdzKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvcltvcF0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkZXNjcmlwdG9yW29wXS5hcHBseShwcm9taXNlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZmFsbGJhY2suY2FsbChwcm9taXNlLCBvcCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcm9taXNlLmluc3BlY3QgPSBpbnNwZWN0O1xuXG4gICAgLy8gWFhYIGRlcHJlY2F0ZWQgYHZhbHVlT2ZgIGFuZCBgZXhjZXB0aW9uYCBzdXBwb3J0XG4gICAgaWYgKGluc3BlY3QpIHtcbiAgICAgICAgdmFyIGluc3BlY3RlZCA9IGluc3BlY3QoKTtcbiAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgICAgICAgICBwcm9taXNlLmV4Y2VwdGlvbiA9IGluc3BlY3RlZC5yZWFzb247XG4gICAgICAgIH1cblxuICAgICAgICBwcm9taXNlLnZhbHVlT2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaW5zcGVjdGVkID0gaW5zcGVjdCgpO1xuICAgICAgICAgICAgaWYgKGluc3BlY3RlZC5zdGF0ZSA9PT0gXCJwZW5kaW5nXCIgfHxcbiAgICAgICAgICAgICAgICBpbnNwZWN0ZWQuc3RhdGUgPT09IFwicmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RlZC52YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBQcm9taXNlXVwiO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIGRvbmUgPSBmYWxzZTsgICAvLyBlbnN1cmUgdGhlIHVudHJ1c3RlZCBwcm9taXNlIG1ha2VzIGF0IG1vc3QgYVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGNhbGwgdG8gb25lIG9mIHRoZSBjYWxsYmFja3NcblxuICAgIGZ1bmN0aW9uIF9mdWxmaWxsZWQodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZnVsZmlsbGVkID09PSBcImZ1bmN0aW9uXCIgPyBmdWxmaWxsZWQodmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChleGNlcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3JlamVjdGVkKGV4Y2VwdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIHJlamVjdGVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIG1ha2VTdGFja1RyYWNlTG9uZyhleGNlcHRpb24sIHNlbGYpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKG5ld0V4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3RXhjZXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX3Byb2dyZXNzZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcm9ncmVzc2VkID09PSBcImZ1bmN0aW9uXCIgPyBwcm9ncmVzc2VkKHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cblxuICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnByb21pc2VEaXNwYXRjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoX2Z1bGZpbGxlZCh2YWx1ZSkpO1xuICAgICAgICB9LCBcIndoZW5cIiwgW2Z1bmN0aW9uIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoX3JlamVjdGVkKGV4Y2VwdGlvbikpO1xuICAgICAgICB9XSk7XG4gICAgfSk7XG5cbiAgICAvLyBQcm9ncmVzcyBwcm9wYWdhdG9yIG5lZWQgdG8gYmUgYXR0YWNoZWQgaW4gdGhlIGN1cnJlbnQgdGljay5cbiAgICBzZWxmLnByb21pc2VEaXNwYXRjaCh2b2lkIDAsIFwid2hlblwiLCBbdm9pZCAwLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlO1xuICAgICAgICB2YXIgdGhyZXcgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gX3Byb2dyZXNzZWQodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJldyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoUS5vbmVycm9yKSB7XG4gICAgICAgICAgICAgICAgUS5vbmVycm9yKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aHJldykge1xuICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuUS50YXAgPSBmdW5jdGlvbiAocHJvbWlzZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50YXAoY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBXb3JrcyBhbG1vc3QgbGlrZSBcImZpbmFsbHlcIiwgYnV0IG5vdCBjYWxsZWQgZm9yIHJlamVjdGlvbnMuXG4gKiBPcmlnaW5hbCByZXNvbHV0aW9uIHZhbHVlIGlzIHBhc3NlZCB0aHJvdWdoIGNhbGxiYWNrIHVuYWZmZWN0ZWQuXG4gKiBDYWxsYmFjayBtYXkgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgYXdhaXRlZCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge1EuUHJvbWlzZX1cbiAqIEBleGFtcGxlXG4gKiBkb1NvbWV0aGluZygpXG4gKiAgIC50aGVuKC4uLilcbiAqICAgLnRhcChjb25zb2xlLmxvZylcbiAqICAgLnRoZW4oLi4uKTtcbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUudGFwID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sgPSBRKGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5mY2FsbCh2YWx1ZSkudGhlblJlc29sdmUodmFsdWUpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYW4gb2JzZXJ2ZXIgb24gYSBwcm9taXNlLlxuICpcbiAqIEd1YXJhbnRlZXM6XG4gKlxuICogMS4gdGhhdCBmdWxmaWxsZWQgYW5kIHJlamVjdGVkIHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZS5cbiAqIDIuIHRoYXQgZWl0aGVyIHRoZSBmdWxmaWxsZWQgY2FsbGJhY2sgb3IgdGhlIHJlamVjdGVkIGNhbGxiYWNrIHdpbGwgYmVcbiAqICAgIGNhbGxlZCwgYnV0IG5vdCBib3RoLlxuICogMy4gdGhhdCBmdWxmaWxsZWQgYW5kIHJlamVjdGVkIHdpbGwgbm90IGJlIGNhbGxlZCBpbiB0aGlzIHR1cm4uXG4gKlxuICogQHBhcmFtIHZhbHVlICAgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIHRvIG9ic2VydmVcbiAqIEBwYXJhbSBmdWxmaWxsZWQgIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBmdWxmaWxsZWQgdmFsdWVcbiAqIEBwYXJhbSByZWplY3RlZCAgIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSByZWplY3Rpb24gZXhjZXB0aW9uXG4gKiBAcGFyYW0gcHJvZ3Jlc3NlZCBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gYW55IHByb2dyZXNzIG5vdGlmaWNhdGlvbnNcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBpbnZva2VkIGNhbGxiYWNrXG4gKi9cblEud2hlbiA9IHdoZW47XG5mdW5jdGlvbiB3aGVuKHZhbHVlLCBmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzc2VkKSB7XG4gICAgcmV0dXJuIFEodmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3NlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnRoZW5SZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiB2YWx1ZTsgfSk7XG59O1xuXG5RLnRoZW5SZXNvbHZlID0gZnVuY3Rpb24gKHByb21pc2UsIHZhbHVlKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZSkudGhlblJlc29sdmUodmFsdWUpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlblJlamVjdCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICgpIHsgdGhyb3cgcmVhc29uOyB9KTtcbn07XG5cblEudGhlblJlamVjdCA9IGZ1bmN0aW9uIChwcm9taXNlLCByZWFzb24pIHtcbiAgICByZXR1cm4gUShwcm9taXNlKS50aGVuUmVqZWN0KHJlYXNvbik7XG59O1xuXG4vKipcbiAqIElmIGFuIG9iamVjdCBpcyBub3QgYSBwcm9taXNlLCBpdCBpcyBhcyBcIm5lYXJcIiBhcyBwb3NzaWJsZS5cbiAqIElmIGEgcHJvbWlzZSBpcyByZWplY3RlZCwgaXQgaXMgYXMgXCJuZWFyXCIgYXMgcG9zc2libGUgdG9vLlxuICogSWYgaXTigJlzIGEgZnVsZmlsbGVkIHByb21pc2UsIHRoZSBmdWxmaWxsbWVudCB2YWx1ZSBpcyBuZWFyZXIuXG4gKiBJZiBpdOKAmXMgYSBkZWZlcnJlZCBwcm9taXNlIGFuZCB0aGUgZGVmZXJyZWQgaGFzIGJlZW4gcmVzb2x2ZWQsIHRoZVxuICogcmVzb2x1dGlvbiBpcyBcIm5lYXJlclwiLlxuICogQHBhcmFtIG9iamVjdFxuICogQHJldHVybnMgbW9zdCByZXNvbHZlZCAobmVhcmVzdCkgZm9ybSBvZiB0aGUgb2JqZWN0XG4gKi9cblxuLy8gWFhYIHNob3VsZCB3ZSByZS1kbyB0aGlzP1xuUS5uZWFyZXIgPSBuZWFyZXI7XG5mdW5jdGlvbiBuZWFyZXIodmFsdWUpIHtcbiAgICBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgICB2YXIgaW5zcGVjdGVkID0gdmFsdWUuaW5zcGVjdCgpO1xuICAgICAgICBpZiAoaW5zcGVjdGVkLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zcGVjdGVkLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSBwcm9taXNlLlxuICogT3RoZXJ3aXNlIGl0IGlzIGEgZnVsZmlsbGVkIHZhbHVlLlxuICovXG5RLmlzUHJvbWlzZSA9IGlzUHJvbWlzZTtcbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgUHJvbWlzZTtcbn1cblxuUS5pc1Byb21pc2VBbGlrZSA9IGlzUHJvbWlzZUFsaWtlO1xuZnVuY3Rpb24gaXNQcm9taXNlQWxpa2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iamVjdCkgJiYgdHlwZW9mIG9iamVjdC50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgcGVuZGluZyBwcm9taXNlLCBtZWFuaW5nIG5vdFxuICogZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuICovXG5RLmlzUGVuZGluZyA9IGlzUGVuZGluZztcbmZ1bmN0aW9uIGlzUGVuZGluZyhvYmplY3QpIHtcbiAgICByZXR1cm4gaXNQcm9taXNlKG9iamVjdCkgJiYgb2JqZWN0Lmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJwZW5kaW5nXCI7XG59XG5cblByb21pc2UucHJvdG90eXBlLmlzUGVuZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnNwZWN0KCkuc3RhdGUgPT09IFwicGVuZGluZ1wiO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSB2YWx1ZSBvciBmdWxmaWxsZWRcbiAqIHByb21pc2UuXG4gKi9cblEuaXNGdWxmaWxsZWQgPSBpc0Z1bGZpbGxlZDtcbmZ1bmN0aW9uIGlzRnVsZmlsbGVkKG9iamVjdCkge1xuICAgIHJldHVybiAhaXNQcm9taXNlKG9iamVjdCkgfHwgb2JqZWN0Lmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIjtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuaXNGdWxmaWxsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zcGVjdCgpLnN0YXRlID09PSBcImZ1bGZpbGxlZFwiO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgaXMgYSByZWplY3RlZCBwcm9taXNlLlxuICovXG5RLmlzUmVqZWN0ZWQgPSBpc1JlamVjdGVkO1xuZnVuY3Rpb24gaXNSZWplY3RlZChvYmplY3QpIHtcbiAgICByZXR1cm4gaXNQcm9taXNlKG9iamVjdCkgJiYgb2JqZWN0Lmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5pc1JlamVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluc3BlY3QoKS5zdGF0ZSA9PT0gXCJyZWplY3RlZFwiO1xufTtcblxuLy8vLyBCRUdJTiBVTkhBTkRMRUQgUkVKRUNUSU9OIFRSQUNLSU5HXG5cbi8vIFRoaXMgcHJvbWlzZSBsaWJyYXJ5IGNvbnN1bWVzIGV4Y2VwdGlvbnMgdGhyb3duIGluIGhhbmRsZXJzIHNvIHRoZXkgY2FuIGJlXG4vLyBoYW5kbGVkIGJ5IGEgc3Vic2VxdWVudCBwcm9taXNlLiAgVGhlIGV4Y2VwdGlvbnMgZ2V0IGFkZGVkIHRvIHRoaXMgYXJyYXkgd2hlblxuLy8gdGhleSBhcmUgY3JlYXRlZCwgYW5kIHJlbW92ZWQgd2hlbiB0aGV5IGFyZSBoYW5kbGVkLiAgTm90ZSB0aGF0IGluIEVTNiBvclxuLy8gc2hpbW1lZCBlbnZpcm9ubWVudHMsIHRoaXMgd291bGQgbmF0dXJhbGx5IGJlIGEgYFNldGAuXG52YXIgdW5oYW5kbGVkUmVhc29ucyA9IFtdO1xudmFyIHVuaGFuZGxlZFJlamVjdGlvbnMgPSBbXTtcbnZhciByZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMgPSBbXTtcbnZhciB0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMgPSB0cnVlO1xuXG5mdW5jdGlvbiByZXNldFVuaGFuZGxlZFJlamVjdGlvbnMoKSB7XG4gICAgdW5oYW5kbGVkUmVhc29ucy5sZW5ndGggPSAwO1xuICAgIHVuaGFuZGxlZFJlamVjdGlvbnMubGVuZ3RoID0gMDtcblxuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB0cmFja1JlamVjdGlvbihwcm9taXNlLCByZWFzb24pIHtcbiAgICBpZiAoIXRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcHJvY2Vzcy5lbWl0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgUS5uZXh0VGljay5ydW5BZnRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlfaW5kZXhPZih1bmhhbmRsZWRSZWplY3Rpb25zLCBwcm9taXNlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIiwgcmVhc29uLCBwcm9taXNlKTtcbiAgICAgICAgICAgICAgICByZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdW5oYW5kbGVkUmVqZWN0aW9ucy5wdXNoKHByb21pc2UpO1xuICAgIGlmIChyZWFzb24gJiYgdHlwZW9mIHJlYXNvbi5zdGFjayAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB1bmhhbmRsZWRSZWFzb25zLnB1c2gocmVhc29uLnN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB1bmhhbmRsZWRSZWFzb25zLnB1c2goXCIobm8gc3RhY2spIFwiICsgcmVhc29uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVudHJhY2tSZWplY3Rpb24ocHJvbWlzZSkge1xuICAgIGlmICghdHJhY2tVbmhhbmRsZWRSZWplY3Rpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXQgPSBhcnJheV9pbmRleE9mKHVuaGFuZGxlZFJlamVjdGlvbnMsIHByb21pc2UpO1xuICAgIGlmIChhdCAhPT0gLTEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLmVtaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgUS5uZXh0VGljay5ydW5BZnRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0UmVwb3J0ID0gYXJyYXlfaW5kZXhPZihyZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMsIHByb21pc2UpO1xuICAgICAgICAgICAgICAgIGlmIChhdFJlcG9ydCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbWl0KFwicmVqZWN0aW9uSGFuZGxlZFwiLCB1bmhhbmRsZWRSZWFzb25zW2F0XSwgcHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcG9ydGVkVW5oYW5kbGVkUmVqZWN0aW9ucy5zcGxpY2UoYXRSZXBvcnQsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHVuaGFuZGxlZFJlamVjdGlvbnMuc3BsaWNlKGF0LCAxKTtcbiAgICAgICAgdW5oYW5kbGVkUmVhc29ucy5zcGxpY2UoYXQsIDEpO1xuICAgIH1cbn1cblxuUS5yZXNldFVuaGFuZGxlZFJlamVjdGlvbnMgPSByZXNldFVuaGFuZGxlZFJlamVjdGlvbnM7XG5cblEuZ2V0VW5oYW5kbGVkUmVhc29ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyB0aGF0IGNvbnN1bWVycyBjYW4ndCBpbnRlcmZlcmUgd2l0aCBvdXIgaW50ZXJuYWwgc3RhdGUuXG4gICAgcmV0dXJuIHVuaGFuZGxlZFJlYXNvbnMuc2xpY2UoKTtcbn07XG5cblEuc3RvcFVuaGFuZGxlZFJlamVjdGlvblRyYWNraW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJlc2V0VW5oYW5kbGVkUmVqZWN0aW9ucygpO1xuICAgIHRyYWNrVW5oYW5kbGVkUmVqZWN0aW9ucyA9IGZhbHNlO1xufTtcblxucmVzZXRVbmhhbmRsZWRSZWplY3Rpb25zKCk7XG5cbi8vLy8gRU5EIFVOSEFORExFRCBSRUpFQ1RJT04gVFJBQ0tJTkdcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqIEBwYXJhbSByZWFzb24gdmFsdWUgZGVzY3JpYmluZyB0aGUgZmFpbHVyZVxuICovXG5RLnJlamVjdCA9IHJlamVjdDtcbmZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICB2YXIgcmVqZWN0aW9uID0gUHJvbWlzZSh7XG4gICAgICAgIFwid2hlblwiOiBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCB0aGUgZXJyb3IgaGFzIGJlZW4gaGFuZGxlZFxuICAgICAgICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdW50cmFja1JlamVjdGlvbih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWplY3RlZCA/IHJlamVjdGVkKHJlYXNvbikgOiB0aGlzO1xuICAgICAgICB9XG4gICAgfSwgZnVuY3Rpb24gZmFsbGJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBcInJlamVjdGVkXCIsIHJlYXNvbjogcmVhc29uIH07XG4gICAgfSk7XG5cbiAgICAvLyBOb3RlIHRoYXQgdGhlIHJlYXNvbiBoYXMgbm90IGJlZW4gaGFuZGxlZC5cbiAgICB0cmFja1JlamVjdGlvbihyZWplY3Rpb24sIHJlYXNvbik7XG5cbiAgICByZXR1cm4gcmVqZWN0aW9uO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBmdWxmaWxsZWQgcHJvbWlzZSBmb3IgYW4gaW1tZWRpYXRlIHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB2YWx1ZSBpbW1lZGlhdGUgcmVmZXJlbmNlXG4gKi9cblEuZnVsZmlsbCA9IGZ1bGZpbGw7XG5mdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2Uoe1xuICAgICAgICBcIndoZW5cIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBcImdldFwiOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlW25hbWVdO1xuICAgICAgICB9LFxuICAgICAgICBcInNldFwiOiBmdW5jdGlvbiAobmFtZSwgcmhzKSB7XG4gICAgICAgICAgICB2YWx1ZVtuYW1lXSA9IHJocztcbiAgICAgICAgfSxcbiAgICAgICAgXCJkZWxldGVcIjogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtuYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJwb3N0XCI6IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICAvLyBNYXJrIE1pbGxlciBwcm9wb3NlcyB0aGF0IHBvc3Qgd2l0aCBubyBuYW1lIHNob3VsZCBhcHBseSBhXG4gICAgICAgICAgICAvLyBwcm9taXNlZCBmdW5jdGlvbi5cbiAgICAgICAgICAgIGlmIChuYW1lID09PSBudWxsIHx8IG5hbWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVbbmFtZV0uYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImFwcGx5XCI6IGZ1bmN0aW9uICh0aGlzcCwgYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRoaXNwLCBhcmdzKTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJrZXlzXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3Rfa2V5cyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCB2b2lkIDAsIGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZTogdmFsdWUgfTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGVuYWJsZXMgdG8gUSBwcm9taXNlcy5cbiAqIEBwYXJhbSBwcm9taXNlIHRoZW5hYmxlIHByb21pc2VcbiAqIEByZXR1cm5zIGEgUSBwcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZShwcm9taXNlKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihkZWZlcnJlZC5yZXNvbHZlLCBkZWZlcnJlZC5yZWplY3QsIGRlZmVycmVkLm5vdGlmeSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuLyoqXG4gKiBBbm5vdGF0ZXMgYW4gb2JqZWN0IHN1Y2ggdGhhdCBpdCB3aWxsIG5ldmVyIGJlXG4gKiB0cmFuc2ZlcnJlZCBhd2F5IGZyb20gdGhpcyBwcm9jZXNzIG92ZXIgYW55IHByb21pc2VcbiAqIGNvbW11bmljYXRpb24gY2hhbm5lbC5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIHByb21pc2UgYSB3cmFwcGluZyBvZiB0aGF0IG9iamVjdCB0aGF0XG4gKiBhZGRpdGlvbmFsbHkgcmVzcG9uZHMgdG8gdGhlIFwiaXNEZWZcIiBtZXNzYWdlXG4gKiB3aXRob3V0IGEgcmVqZWN0aW9uLlxuICovXG5RLm1hc3RlciA9IG1hc3RlcjtcbmZ1bmN0aW9uIG1hc3RlcihvYmplY3QpIHtcbiAgICByZXR1cm4gUHJvbWlzZSh7XG4gICAgICAgIFwiaXNEZWZcIjogZnVuY3Rpb24gKCkge31cbiAgICB9LCBmdW5jdGlvbiBmYWxsYmFjayhvcCwgYXJncykge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2gob2JqZWN0LCBvcCwgYXJncyk7XG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gUShvYmplY3QpLmluc3BlY3QoKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBTcHJlYWRzIHRoZSB2YWx1ZXMgb2YgYSBwcm9taXNlZCBhcnJheSBvZiBhcmd1bWVudHMgaW50byB0aGVcbiAqIGZ1bGZpbGxtZW50IGNhbGxiYWNrLlxuICogQHBhcmFtIGZ1bGZpbGxlZCBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHZhcmlhZGljIGFyZ3VtZW50cyBmcm9tIHRoZVxuICogcHJvbWlzZWQgYXJyYXlcbiAqIEBwYXJhbSByZWplY3RlZCBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIHRoZSBleGNlcHRpb24gaWYgdGhlIHByb21pc2VcbiAqIGlzIHJlamVjdGVkLlxuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlIG9yIHRocm93biBleGNlcHRpb24gb2ZcbiAqIGVpdGhlciBjYWxsYmFjay5cbiAqL1xuUS5zcHJlYWQgPSBzcHJlYWQ7XG5mdW5jdGlvbiBzcHJlYWQodmFsdWUsIGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gUSh2YWx1ZSkuc3ByZWFkKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5zcHJlYWQgPSBmdW5jdGlvbiAoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLmFsbCgpLnRoZW4oZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgIHJldHVybiBmdWxmaWxsZWQuYXBwbHkodm9pZCAwLCBhcnJheSk7XG4gICAgfSwgcmVqZWN0ZWQpO1xufTtcblxuLyoqXG4gKiBUaGUgYXN5bmMgZnVuY3Rpb24gaXMgYSBkZWNvcmF0b3IgZm9yIGdlbmVyYXRvciBmdW5jdGlvbnMsIHR1cm5pbmdcbiAqIHRoZW0gaW50byBhc3luY2hyb25vdXMgZ2VuZXJhdG9ycy4gIEFsdGhvdWdoIGdlbmVyYXRvcnMgYXJlIG9ubHkgcGFydFxuICogb2YgdGhlIG5ld2VzdCBFQ01BU2NyaXB0IDYgZHJhZnRzLCB0aGlzIGNvZGUgZG9lcyBub3QgY2F1c2Ugc3ludGF4XG4gKiBlcnJvcnMgaW4gb2xkZXIgZW5naW5lcy4gIFRoaXMgY29kZSBzaG91bGQgY29udGludWUgdG8gd29yayBhbmQgd2lsbFxuICogaW4gZmFjdCBpbXByb3ZlIG92ZXIgdGltZSBhcyB0aGUgbGFuZ3VhZ2UgaW1wcm92ZXMuXG4gKlxuICogRVM2IGdlbmVyYXRvcnMgYXJlIGN1cnJlbnRseSBwYXJ0IG9mIFY4IHZlcnNpb24gMy4xOSB3aXRoIHRoZVxuICogLS1oYXJtb255LWdlbmVyYXRvcnMgcnVudGltZSBmbGFnIGVuYWJsZWQuICBTcGlkZXJNb25rZXkgaGFzIGhhZCB0aGVtXG4gKiBmb3IgbG9uZ2VyLCBidXQgdW5kZXIgYW4gb2xkZXIgUHl0aG9uLWluc3BpcmVkIGZvcm0uICBUaGlzIGZ1bmN0aW9uXG4gKiB3b3JrcyBvbiBib3RoIGtpbmRzIG9mIGdlbmVyYXRvcnMuXG4gKlxuICogRGVjb3JhdGVzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHN1Y2ggdGhhdDpcbiAqICAtIGl0IG1heSB5aWVsZCBwcm9taXNlc1xuICogIC0gZXhlY3V0aW9uIHdpbGwgY29udGludWUgd2hlbiB0aGF0IHByb21pc2UgaXMgZnVsZmlsbGVkXG4gKiAgLSB0aGUgdmFsdWUgb2YgdGhlIHlpZWxkIGV4cHJlc3Npb24gd2lsbCBiZSB0aGUgZnVsZmlsbGVkIHZhbHVlXG4gKiAgLSBpdCByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZSAod2hlbiB0aGUgZ2VuZXJhdG9yXG4gKiAgICBzdG9wcyBpdGVyYXRpbmcpXG4gKiAgLSB0aGUgZGVjb3JhdGVkIGZ1bmN0aW9uIHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKiAgICBvZiB0aGUgZ2VuZXJhdG9yIG9yIHRoZSBmaXJzdCByZWplY3RlZCBwcm9taXNlIGFtb25nIHRob3NlXG4gKiAgICB5aWVsZGVkLlxuICogIC0gaWYgYW4gZXJyb3IgaXMgdGhyb3duIGluIHRoZSBnZW5lcmF0b3IsIGl0IHByb3BhZ2F0ZXMgdGhyb3VnaFxuICogICAgZXZlcnkgZm9sbG93aW5nIHlpZWxkIHVudGlsIGl0IGlzIGNhdWdodCwgb3IgdW50aWwgaXQgZXNjYXBlc1xuICogICAgdGhlIGdlbmVyYXRvciBmdW5jdGlvbiBhbHRvZ2V0aGVyLCBhbmQgaXMgdHJhbnNsYXRlZCBpbnRvIGFcbiAqICAgIHJlamVjdGlvbiBmb3IgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGRlY29yYXRlZCBnZW5lcmF0b3IuXG4gKi9cblEuYXN5bmMgPSBhc3luYztcbmZ1bmN0aW9uIGFzeW5jKG1ha2VHZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB3aGVuIHZlcmIgaXMgXCJzZW5kXCIsIGFyZyBpcyBhIHZhbHVlXG4gICAgICAgIC8vIHdoZW4gdmVyYiBpcyBcInRocm93XCIsIGFyZyBpcyBhbiBleGNlcHRpb25cbiAgICAgICAgZnVuY3Rpb24gY29udGludWVyKHZlcmIsIGFyZykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAgICAgLy8gVW50aWwgVjggMy4xOSAvIENocm9taXVtIDI5IGlzIHJlbGVhc2VkLCBTcGlkZXJNb25rZXkgaXMgdGhlIG9ubHlcbiAgICAgICAgICAgIC8vIGVuZ2luZSB0aGF0IGhhcyBhIGRlcGxveWVkIGJhc2Ugb2YgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGdlbmVyYXRvcnMuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCBTTSdzIGdlbmVyYXRvcnMgdXNlIHRoZSBQeXRob24taW5zcGlyZWQgc2VtYW50aWNzIG9mXG4gICAgICAgICAgICAvLyBvdXRkYXRlZCBFUzYgZHJhZnRzLiAgV2Ugd291bGQgbGlrZSB0byBzdXBwb3J0IEVTNiwgYnV0IHdlJ2QgYWxzb1xuICAgICAgICAgICAgLy8gbGlrZSB0byBtYWtlIGl0IHBvc3NpYmxlIHRvIHVzZSBnZW5lcmF0b3JzIGluIGRlcGxveWVkIGJyb3dzZXJzLCBzb1xuICAgICAgICAgICAgLy8gd2UgYWxzbyBzdXBwb3J0IFB5dGhvbi1zdHlsZSBnZW5lcmF0b3JzLiAgQXQgc29tZSBwb2ludCB3ZSBjYW4gcmVtb3ZlXG4gICAgICAgICAgICAvLyB0aGlzIGJsb2NrLlxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIFN0b3BJdGVyYXRpb24gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBFUzYgR2VuZXJhdG9yc1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRvclt2ZXJiXShhcmcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aGVuKHJlc3VsdC52YWx1ZSwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3BpZGVyTW9ua2V5IEdlbmVyYXRvcnNcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogUmVtb3ZlIHRoaXMgY2FzZSB3aGVuIFNNIGRvZXMgRVM2IGdlbmVyYXRvcnMuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gZ2VuZXJhdG9yW3ZlcmJdKGFyZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1N0b3BJdGVyYXRpb24oZXhjZXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFEoZXhjZXB0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gd2hlbihyZXN1bHQsIGNhbGxiYWNrLCBlcnJiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gbWFrZUdlbmVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjb250aW51ZXIuYmluZChjb250aW51ZXIsIFwibmV4dFwiKTtcbiAgICAgICAgdmFyIGVycmJhY2sgPSBjb250aW51ZXIuYmluZChjb250aW51ZXIsIFwidGhyb3dcIik7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG59XG5cbi8qKlxuICogVGhlIHNwYXduIGZ1bmN0aW9uIGlzIGEgc21hbGwgd3JhcHBlciBhcm91bmQgYXN5bmMgdGhhdCBpbW1lZGlhdGVseVxuICogY2FsbHMgdGhlIGdlbmVyYXRvciBhbmQgYWxzbyBlbmRzIHRoZSBwcm9taXNlIGNoYWluLCBzbyB0aGF0IGFueVxuICogdW5oYW5kbGVkIGVycm9ycyBhcmUgdGhyb3duIGluc3RlYWQgb2YgZm9yd2FyZGVkIHRvIHRoZSBlcnJvclxuICogaGFuZGxlci4gVGhpcyBpcyB1c2VmdWwgYmVjYXVzZSBpdCdzIGV4dHJlbWVseSBjb21tb24gdG8gcnVuXG4gKiBnZW5lcmF0b3JzIGF0IHRoZSB0b3AtbGV2ZWwgdG8gd29yayB3aXRoIGxpYnJhcmllcy5cbiAqL1xuUS5zcGF3biA9IHNwYXduO1xuZnVuY3Rpb24gc3Bhd24obWFrZUdlbmVyYXRvcikge1xuICAgIFEuZG9uZShRLmFzeW5jKG1ha2VHZW5lcmF0b3IpKCkpO1xufVxuXG4vLyBGSVhNRTogUmVtb3ZlIHRoaXMgaW50ZXJmYWNlIG9uY2UgRVM2IGdlbmVyYXRvcnMgYXJlIGluIFNwaWRlck1vbmtleS5cbi8qKlxuICogVGhyb3dzIGEgUmV0dXJuVmFsdWUgZXhjZXB0aW9uIHRvIHN0b3AgYW4gYXN5bmNocm9ub3VzIGdlbmVyYXRvci5cbiAqXG4gKiBUaGlzIGludGVyZmFjZSBpcyBhIHN0b3AtZ2FwIG1lYXN1cmUgdG8gc3VwcG9ydCBnZW5lcmF0b3IgcmV0dXJuXG4gKiB2YWx1ZXMgaW4gb2xkZXIgRmlyZWZveC9TcGlkZXJNb25rZXkuICBJbiBicm93c2VycyB0aGF0IHN1cHBvcnQgRVM2XG4gKiBnZW5lcmF0b3JzIGxpa2UgQ2hyb21pdW0gMjksIGp1c3QgdXNlIFwicmV0dXJuXCIgaW4geW91ciBnZW5lcmF0b3JcbiAqIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHJldHVybiB2YWx1ZSBmb3IgdGhlIHN1cnJvdW5kaW5nIGdlbmVyYXRvclxuICogQHRocm93cyBSZXR1cm5WYWx1ZSBleGNlcHRpb24gd2l0aCB0aGUgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICogLy8gRVM2IHN0eWxlXG4gKiBRLmFzeW5jKGZ1bmN0aW9uKiAoKSB7XG4gKiAgICAgIHZhciBmb28gPSB5aWVsZCBnZXRGb29Qcm9taXNlKCk7XG4gKiAgICAgIHZhciBiYXIgPSB5aWVsZCBnZXRCYXJQcm9taXNlKCk7XG4gKiAgICAgIHJldHVybiBmb28gKyBiYXI7XG4gKiB9KVxuICogLy8gT2xkZXIgU3BpZGVyTW9ua2V5IHN0eWxlXG4gKiBRLmFzeW5jKGZ1bmN0aW9uICgpIHtcbiAqICAgICAgdmFyIGZvbyA9IHlpZWxkIGdldEZvb1Byb21pc2UoKTtcbiAqICAgICAgdmFyIGJhciA9IHlpZWxkIGdldEJhclByb21pc2UoKTtcbiAqICAgICAgUS5yZXR1cm4oZm9vICsgYmFyKTtcbiAqIH0pXG4gKi9cblFbXCJyZXR1cm5cIl0gPSBfcmV0dXJuO1xuZnVuY3Rpb24gX3JldHVybih2YWx1ZSkge1xuICAgIHRocm93IG5ldyBRUmV0dXJuVmFsdWUodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBwcm9taXNlZCBmdW5jdGlvbiBkZWNvcmF0b3IgZW5zdXJlcyB0aGF0IGFueSBwcm9taXNlIGFyZ3VtZW50c1xuICogYXJlIHNldHRsZWQgYW5kIHBhc3NlZCBhcyB2YWx1ZXMgKGB0aGlzYCBpcyBhbHNvIHNldHRsZWQgYW5kIHBhc3NlZFxuICogYXMgYSB2YWx1ZSkuICBJdCB3aWxsIGFsc28gZW5zdXJlIHRoYXQgdGhlIHJlc3VsdCBvZiBhIGZ1bmN0aW9uIGlzXG4gKiBhbHdheXMgYSBwcm9taXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgYWRkID0gUS5wcm9taXNlZChmdW5jdGlvbiAoYSwgYikge1xuICogICAgIHJldHVybiBhICsgYjtcbiAqIH0pO1xuICogYWRkKFEoYSksIFEoQikpO1xuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBkZWNvcmF0ZVxuICogQHJldHVybnMge2Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgaGFzIGJlZW4gZGVjb3JhdGVkLlxuICovXG5RLnByb21pc2VkID0gcHJvbWlzZWQ7XG5mdW5jdGlvbiBwcm9taXNlZChjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzcHJlYWQoW3RoaXMsIGFsbChhcmd1bWVudHMpXSwgZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBzZW5kcyBhIG1lc3NhZ2UgdG8gYSB2YWx1ZSBpbiBhIGZ1dHVyZSB0dXJuXG4gKiBAcGFyYW0gb2JqZWN0KiB0aGUgcmVjaXBpZW50XG4gKiBAcGFyYW0gb3AgdGhlIG5hbWUgb2YgdGhlIG1lc3NhZ2Ugb3BlcmF0aW9uLCBlLmcuLCBcIndoZW5cIixcbiAqIEBwYXJhbSBhcmdzIGZ1cnRoZXIgYXJndW1lbnRzIHRvIGJlIGZvcndhcmRlZCB0byB0aGUgb3BlcmF0aW9uXG4gKiBAcmV0dXJucyByZXN1bHQge1Byb21pc2V9IGEgcHJvbWlzZSBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG4gKi9cblEuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbmZ1bmN0aW9uIGRpc3BhdGNoKG9iamVjdCwgb3AsIGFyZ3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKG9wLCBhcmdzKTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAob3AsIGFyZ3MpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBRLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5wcm9taXNlRGlzcGF0Y2goZGVmZXJyZWQucmVzb2x2ZSwgb3AsIGFyZ3MpO1xuICAgIH0pO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIGdldFxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcHJvcGVydHkgdmFsdWVcbiAqL1xuUS5nZXQgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXkpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRpc3BhdGNoKFwiZ2V0XCIsIFtrZXldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImdldFwiLCBba2V5XSk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciBvYmplY3Qgb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSAgICAgIG5hbWUgb2YgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0gdmFsdWUgICAgIG5ldyB2YWx1ZSBvZiBwcm9wZXJ0eVxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuc2V0ID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJzZXRcIiwgW2tleSwgdmFsdWVdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJzZXRcIiwgW2tleSwgdmFsdWVdKTtcbn07XG5cbi8qKlxuICogRGVsZXRlcyBhIHByb3BlcnR5IGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIHByb3BlcnR5IHRvIGRlbGV0ZVxuICogQHJldHVybiBwcm9taXNlIGZvciB0aGUgcmV0dXJuIHZhbHVlXG4gKi9cblEuZGVsID0gLy8gWFhYIGxlZ2FjeVxuUVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJkZWxldGVcIiwgW2tleV0pO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZGVsID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJkZWxldGVcIiwgW2tleV0pO1xufTtcblxuLyoqXG4gKiBJbnZva2VzIGEgbWV0aG9kIGluIGEgZnV0dXJlIHR1cm4uXG4gKiBAcGFyYW0gb2JqZWN0ICAgIHByb21pc2Ugb3IgaW1tZWRpYXRlIHJlZmVyZW5jZSBmb3IgdGFyZ2V0IG9iamVjdFxuICogQHBhcmFtIG5hbWUgICAgICBuYW1lIG9mIG1ldGhvZCB0byBpbnZva2VcbiAqIEBwYXJhbSB2YWx1ZSAgICAgYSB2YWx1ZSB0byBwb3N0LCB0eXBpY2FsbHkgYW4gYXJyYXkgb2ZcbiAqICAgICAgICAgICAgICAgICAgaW52b2NhdGlvbiBhcmd1bWVudHMgZm9yIHByb21pc2VzIHRoYXRcbiAqICAgICAgICAgICAgICAgICAgYXJlIHVsdGltYXRlbHkgYmFja2VkIHdpdGggYHJlc29sdmVgIHZhbHVlcyxcbiAqICAgICAgICAgICAgICAgICAgYXMgb3Bwb3NlZCB0byB0aG9zZSBiYWNrZWQgd2l0aCBVUkxzXG4gKiAgICAgICAgICAgICAgICAgIHdoZXJlaW4gdGhlIHBvc3RlZCB2YWx1ZSBjYW4gYmUgYW55XG4gKiAgICAgICAgICAgICAgICAgIEpTT04gc2VyaWFsaXphYmxlIG9iamVjdC5cbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIHJldHVybiB2YWx1ZVxuICovXG4vLyBib3VuZCBsb2NhbGx5IGJlY2F1c2UgaXQgaXMgdXNlZCBieSBvdGhlciBtZXRob2RzXG5RLm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLnBvc3QgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFyZ3NdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5Qcm9taXNlLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFyZ3NdKTtcbn07XG5cbi8qKlxuICogSW52b2tlcyBhIG1ldGhvZCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEBwYXJhbSBuYW1lICAgICAgbmFtZSBvZiBtZXRob2QgdG8gaW52b2tlXG4gKiBAcGFyYW0gLi4uYXJncyAgIGFycmF5IG9mIGludm9jYXRpb24gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWVcbiAqL1xuUS5zZW5kID0gLy8gWFhYIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgcGFybGFuY2VcblEubWNhbGwgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUS5pbnZva2UgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lIC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMildKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLnNlbmQgPSAvLyBYWFggTWFyayBNaWxsZXIncyBwcm9wb3NlZCBwYXJsYW5jZVxuUHJvbWlzZS5wcm90b3R5cGUubWNhbGwgPSAvLyBYWFggQXMgcHJvcG9zZWQgYnkgXCJSZWRzYW5kcm9cIlxuUHJvbWlzZS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInBvc3RcIiwgW25hbWUsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSldKTtcbn07XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24gaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSBhcmdzICAgICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblEuZmFwcGx5ID0gZnVuY3Rpb24gKG9iamVjdCwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcmdzXSk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5mYXBwbHkgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwiYXBwbHlcIiwgW3ZvaWQgMCwgYXJnc10pO1xufTtcblxuLyoqXG4gKiBDYWxscyB0aGUgcHJvbWlzZWQgZnVuY3Rpb24gaW4gYSBmdXR1cmUgdHVybi5cbiAqIEBwYXJhbSBvYmplY3QgICAgcHJvbWlzZSBvciBpbW1lZGlhdGUgcmVmZXJlbmNlIGZvciB0YXJnZXQgZnVuY3Rpb25cbiAqIEBwYXJhbSAuLi5hcmdzICAgYXJyYXkgb2YgYXBwbGljYXRpb24gYXJndW1lbnRzXG4gKi9cblFbXCJ0cnlcIl0gPVxuUS5mY2FsbCA9IGZ1bmN0aW9uIChvYmplY3QgLyogLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kaXNwYXRjaChcImFwcGx5XCIsIFt2b2lkIDAsIGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSldKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmZjYWxsID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJhcHBseVwiLCBbdm9pZCAwLCBhcnJheV9zbGljZShhcmd1bWVudHMpXSk7XG59O1xuXG4vKipcbiAqIEJpbmRzIHRoZSBwcm9taXNlZCBmdW5jdGlvbiwgdHJhbnNmb3JtaW5nIHJldHVybiB2YWx1ZXMgaW50byBhIGZ1bGZpbGxlZFxuICogcHJvbWlzZSBhbmQgdGhyb3duIGVycm9ycyBpbnRvIGEgcmVqZWN0ZWQgb25lLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBmdW5jdGlvblxuICogQHBhcmFtIC4uLmFyZ3MgICBhcnJheSBvZiBhcHBsaWNhdGlvbiBhcmd1bWVudHNcbiAqL1xuUS5mYmluZCA9IGZ1bmN0aW9uIChvYmplY3QgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgcHJvbWlzZSA9IFEob2JqZWN0KTtcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuZGlzcGF0Y2goXCJhcHBseVwiLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgXSk7XG4gICAgfTtcbn07XG5Qcm9taXNlLnByb3RvdHlwZS5mYmluZCA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBwcm9taXNlID0gdGhpcztcbiAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZib3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UuZGlzcGF0Y2goXCJhcHBseVwiLCBbXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UoYXJndW1lbnRzKSlcbiAgICAgICAgXSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogUmVxdWVzdHMgdGhlIG5hbWVzIG9mIHRoZSBvd25lZCBwcm9wZXJ0aWVzIG9mIGEgcHJvbWlzZWRcbiAqIG9iamVjdCBpbiBhIGZ1dHVyZSB0dXJuLlxuICogQHBhcmFtIG9iamVjdCAgICBwcm9taXNlIG9yIGltbWVkaWF0ZSByZWZlcmVuY2UgZm9yIHRhcmdldCBvYmplY3RcbiAqIEByZXR1cm4gcHJvbWlzZSBmb3IgdGhlIGtleXMgb2YgdGhlIGV2ZW50dWFsbHkgc2V0dGxlZCBvYmplY3RcbiAqL1xuUS5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBRKG9iamVjdCkuZGlzcGF0Y2goXCJrZXlzXCIsIFtdKTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJrZXlzXCIsIFtdKTtcbn07XG5cbi8qKlxuICogVHVybnMgYW4gYXJyYXkgb2YgcHJvbWlzZXMgaW50byBhIHByb21pc2UgZm9yIGFuIGFycmF5LiAgSWYgYW55IG9mXG4gKiB0aGUgcHJvbWlzZXMgZ2V0cyByZWplY3RlZCwgdGhlIHdob2xlIGFycmF5IGlzIHJlamVjdGVkIGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtBcnJheSp9IGFuIGFycmF5IChvciBwcm9taXNlIGZvciBhbiBhcnJheSkgb2YgdmFsdWVzIChvclxuICogcHJvbWlzZXMgZm9yIHZhbHVlcylcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzXG4gKi9cbi8vIEJ5IE1hcmsgTWlsbGVyXG4vLyBodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1zdHJhd21hbjpjb25jdXJyZW5jeSZyZXY9MTMwODc3NjUyMSNhbGxmdWxmaWxsZWRcblEuYWxsID0gYWxsO1xuZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICB2YXIgcGVuZGluZ0NvdW50ID0gMDtcbiAgICAgICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICAgICAgYXJyYXlfcmVkdWNlKHByb21pc2VzLCBmdW5jdGlvbiAodW5kZWZpbmVkLCBwcm9taXNlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHNuYXBzaG90O1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGlzUHJvbWlzZShwcm9taXNlKSAmJlxuICAgICAgICAgICAgICAgIChzbmFwc2hvdCA9IHByb21pc2UuaW5zcGVjdCgpKS5zdGF0ZSA9PT0gXCJmdWxmaWxsZWRcIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbaW5kZXhdID0gc25hcHNob3QudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICsrcGVuZGluZ0NvdW50O1xuICAgICAgICAgICAgICAgIHdoZW4oXG4gICAgICAgICAgICAgICAgICAgIHByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1wZW5kaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHByb21pc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeSh7IGluZGV4OiBpbmRleCwgdmFsdWU6IHByb2dyZXNzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdm9pZCAwKTtcbiAgICAgICAgaWYgKHBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSk7XG59XG5cblByb21pc2UucHJvdG90eXBlLmFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCByZXNvbHZlZCBwcm9taXNlIG9mIGFuIGFycmF5LiBQcmlvciByZWplY3RlZCBwcm9taXNlcyBhcmVcbiAqIGlnbm9yZWQuICBSZWplY3RzIG9ubHkgaWYgYWxsIHByb21pc2VzIGFyZSByZWplY3RlZC5cbiAqIEBwYXJhbSB7QXJyYXkqfSBhbiBhcnJheSBjb250YWluaW5nIHZhbHVlcyBvciBwcm9taXNlcyBmb3IgdmFsdWVzXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZnVsZmlsbGVkIHdpdGggdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCByZXNvbHZlZCBwcm9taXNlLFxuICogb3IgYSByZWplY3RlZCBwcm9taXNlIGlmIGFsbCBwcm9taXNlcyBhcmUgcmVqZWN0ZWQuXG4gKi9cblEuYW55ID0gYW55O1xuXG5mdW5jdGlvbiBhbnkocHJvbWlzZXMpIHtcbiAgICBpZiAocHJvbWlzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBRLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmZXJyZWQgPSBRLmRlZmVyKCk7XG4gICAgdmFyIHBlbmRpbmdDb3VudCA9IDA7XG4gICAgYXJyYXlfcmVkdWNlKHByb21pc2VzLCBmdW5jdGlvbiAocHJldiwgY3VycmVudCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBwcm9taXNlc1tpbmRleF07XG5cbiAgICAgICAgcGVuZGluZ0NvdW50Kys7XG5cbiAgICAgICAgd2hlbihwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyk7XG4gICAgICAgIGZ1bmN0aW9uIG9uRnVsZmlsbGVkKHJlc3VsdCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uUmVqZWN0ZWQoZXJyKSB7XG4gICAgICAgICAgICBwZW5kaW5nQ291bnQtLTtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVqZWN0aW9uID0gZXJyIHx8IG5ldyBFcnJvcihcIlwiICsgZXJyKTtcblxuICAgICAgICAgICAgICAgIHJlamVjdGlvbi5tZXNzYWdlID0gKFwiUSBjYW4ndCBnZXQgZnVsZmlsbG1lbnQgdmFsdWUgZnJvbSBhbnkgcHJvbWlzZSwgYWxsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJwcm9taXNlcyB3ZXJlIHJlamVjdGVkLiBMYXN0IGVycm9yIG1lc3NhZ2U6IFwiICsgcmVqZWN0aW9uLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlamVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25Qcm9ncmVzcyhwcm9ncmVzcykge1xuICAgICAgICAgICAgZGVmZXJyZWQubm90aWZ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb2dyZXNzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIHVuZGVmaW5lZCk7XG5cbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn1cblxuUHJvbWlzZS5wcm90b3R5cGUuYW55ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhbnkodGhpcyk7XG59O1xuXG4vKipcbiAqIFdhaXRzIGZvciBhbGwgcHJvbWlzZXMgdG8gYmUgc2V0dGxlZCwgZWl0aGVyIGZ1bGZpbGxlZCBvclxuICogcmVqZWN0ZWQuICBUaGlzIGlzIGRpc3RpbmN0IGZyb20gYGFsbGAgc2luY2UgdGhhdCB3b3VsZCBzdG9wXG4gKiB3YWl0aW5nIGF0IHRoZSBmaXJzdCByZWplY3Rpb24uICBUaGUgcHJvbWlzZSByZXR1cm5lZCBieVxuICogYGFsbFJlc29sdmVkYCB3aWxsIG5ldmVyIGJlIHJlamVjdGVkLlxuICogQHBhcmFtIHByb21pc2VzIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgKG9yIGFuIGFycmF5KSBvZiBwcm9taXNlc1xuICogKG9yIHZhbHVlcylcbiAqIEByZXR1cm4gYSBwcm9taXNlIGZvciBhbiBhcnJheSBvZiBwcm9taXNlc1xuICovXG5RLmFsbFJlc29sdmVkID0gZGVwcmVjYXRlKGFsbFJlc29sdmVkLCBcImFsbFJlc29sdmVkXCIsIFwiYWxsU2V0dGxlZFwiKTtcbmZ1bmN0aW9uIGFsbFJlc29sdmVkKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIHdoZW4ocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICBwcm9taXNlcyA9IGFycmF5X21hcChwcm9taXNlcywgUSk7XG4gICAgICAgIHJldHVybiB3aGVuKGFsbChhcnJheV9tYXAocHJvbWlzZXMsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2hlbihwcm9taXNlLCBub29wLCBub29wKTtcbiAgICAgICAgfSkpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZXM7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5hbGxSZXNvbHZlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYWxsUmVzb2x2ZWQodGhpcyk7XG59O1xuXG4vKipcbiAqIEBzZWUgUHJvbWlzZSNhbGxTZXR0bGVkXG4gKi9cblEuYWxsU2V0dGxlZCA9IGFsbFNldHRsZWQ7XG5mdW5jdGlvbiBhbGxTZXR0bGVkKHByb21pc2VzKSB7XG4gICAgcmV0dXJuIFEocHJvbWlzZXMpLmFsbFNldHRsZWQoKTtcbn1cblxuLyoqXG4gKiBUdXJucyBhbiBhcnJheSBvZiBwcm9taXNlcyBpbnRvIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgdGhlaXIgc3RhdGVzIChhc1xuICogcmV0dXJuZWQgYnkgYGluc3BlY3RgKSB3aGVuIHRoZXkgaGF2ZSBhbGwgc2V0dGxlZC5cbiAqIEBwYXJhbSB7QXJyYXlbQW55Kl19IHZhbHVlcyBhbiBhcnJheSAob3IgcHJvbWlzZSBmb3IgYW4gYXJyYXkpIG9mIHZhbHVlcyAob3JcbiAqIHByb21pc2VzIGZvciB2YWx1ZXMpXG4gKiBAcmV0dXJucyB7QXJyYXlbU3RhdGVdfSBhbiBhcnJheSBvZiBzdGF0ZXMgZm9yIHRoZSByZXNwZWN0aXZlIHZhbHVlcy5cbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUuYWxsU2V0dGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIChwcm9taXNlcykge1xuICAgICAgICByZXR1cm4gYWxsKGFycmF5X21hcChwcm9taXNlcywgZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBRKHByb21pc2UpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcmVnYXJkbGVzcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZS5pbnNwZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKHJlZ2FyZGxlc3MsIHJlZ2FyZGxlc3MpO1xuICAgICAgICB9KSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENhcHR1cmVzIHRoZSBmYWlsdXJlIG9mIGEgcHJvbWlzZSwgZ2l2aW5nIGFuIG9wb3J0dW5pdHkgdG8gcmVjb3ZlclxuICogd2l0aCBhIGNhbGxiYWNrLiAgSWYgdGhlIGdpdmVuIHByb21pc2UgaXMgZnVsZmlsbGVkLCB0aGUgcmV0dXJuZWRcbiAqIHByb21pc2UgaXMgZnVsZmlsbGVkLlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlIGZvciBzb21ldGhpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIGZ1bGZpbGwgdGhlIHJldHVybmVkIHByb21pc2UgaWYgdGhlXG4gKiBnaXZlbiBwcm9taXNlIGlzIHJlamVjdGVkXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbGxiYWNrXG4gKi9cblEuZmFpbCA9IC8vIFhYWCBsZWdhY3lcblFbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIHJlamVjdGVkKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aGVuKHZvaWQgMCwgcmVqZWN0ZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmFpbCA9IC8vIFhYWCBsZWdhY3lcblByb21pc2UucHJvdG90eXBlW1wiY2F0Y2hcIl0gPSBmdW5jdGlvbiAocmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgcmVqZWN0ZWQpO1xufTtcblxuLyoqXG4gKiBBdHRhY2hlcyBhIGxpc3RlbmVyIHRoYXQgY2FuIHJlc3BvbmQgdG8gcHJvZ3Jlc3Mgbm90aWZpY2F0aW9ucyBmcm9tIGFcbiAqIHByb21pc2UncyBvcmlnaW5hdGluZyBkZWZlcnJlZC4gVGhpcyBsaXN0ZW5lciByZWNlaXZlcyB0aGUgZXhhY3QgYXJndW1lbnRzXG4gKiBwYXNzZWQgdG8gYGBkZWZlcnJlZC5ub3RpZnlgYC5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBmb3Igc29tZXRoaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0byByZWNlaXZlIGFueSBwcm9ncmVzcyBub3RpZmljYXRpb25zXG4gKiBAcmV0dXJucyB0aGUgZ2l2ZW4gcHJvbWlzZSwgdW5jaGFuZ2VkXG4gKi9cblEucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbmZ1bmN0aW9uIHByb2dyZXNzKG9iamVjdCwgcHJvZ3Jlc3NlZCkge1xuICAgIHJldHVybiBRKG9iamVjdCkudGhlbih2b2lkIDAsIHZvaWQgMCwgcHJvZ3Jlc3NlZCk7XG59XG5cblByb21pc2UucHJvdG90eXBlLnByb2dyZXNzID0gZnVuY3Rpb24gKHByb2dyZXNzZWQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCwgdm9pZCAwLCBwcm9ncmVzc2VkKTtcbn07XG5cbi8qKlxuICogUHJvdmlkZXMgYW4gb3Bwb3J0dW5pdHkgdG8gb2JzZXJ2ZSB0aGUgc2V0dGxpbmcgb2YgYSBwcm9taXNlLFxuICogcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBwcm9taXNlIGlzIGZ1bGZpbGxlZCBvciByZWplY3RlZC4gIEZvcndhcmRzXG4gKiB0aGUgcmVzb2x1dGlvbiB0byB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aGVuIHRoZSBjYWxsYmFjayBpcyBkb25lLlxuICogVGhlIGNhbGxiYWNrIGNhbiByZXR1cm4gYSBwcm9taXNlIHRvIGRlZmVyIGNvbXBsZXRpb24uXG4gKiBAcGFyYW0ge0FueSp9IHByb21pc2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRvIG9ic2VydmUgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuXG4gKiBwcm9taXNlLCB0YWtlcyBubyBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBnaXZlbiBwcm9taXNlIHdoZW5cbiAqIGBgZmluYGAgaXMgZG9uZS5cbiAqL1xuUS5maW4gPSAvLyBYWFggbGVnYWN5XG5RW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KVtcImZpbmFsbHlcIl0oY2FsbGJhY2spO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZmluID0gLy8gWFhYIGxlZ2FjeVxuUHJvbWlzZS5wcm90b3R5cGVbXCJmaW5hbGx5XCJdID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjayB8fCB0eXBlb2YgY2FsbGJhY2suYXBwbHkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJRIGNhbid0IGFwcGx5IGZpbmFsbHkgY2FsbGJhY2tcIik7XG4gICAgfVxuICAgIGNhbGxiYWNrID0gUShjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmZjYWxsKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVE9ETyBhdHRlbXB0IHRvIHJlY3ljbGUgdGhlIHJlamVjdGlvbiB3aXRoIFwidGhpc1wiLlxuICAgICAgICByZXR1cm4gY2FsbGJhY2suZmNhbGwoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFRlcm1pbmF0ZXMgYSBjaGFpbiBvZiBwcm9taXNlcywgZm9yY2luZyByZWplY3Rpb25zIHRvIGJlXG4gKiB0aHJvd24gYXMgZXhjZXB0aW9ucy5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZSBhdCB0aGUgZW5kIG9mIGEgY2hhaW4gb2YgcHJvbWlzZXNcbiAqIEByZXR1cm5zIG5vdGhpbmdcbiAqL1xuUS5kb25lID0gZnVuY3Rpb24gKG9iamVjdCwgZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpIHtcbiAgICByZXR1cm4gUShvYmplY3QpLmRvbmUoZnVsZmlsbGVkLCByZWplY3RlZCwgcHJvZ3Jlc3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykge1xuICAgIHZhciBvblVuaGFuZGxlZEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIC8vIGZvcndhcmQgdG8gYSBmdXR1cmUgdHVybiBzbyB0aGF0IGBgd2hlbmBgXG4gICAgICAgIC8vIGRvZXMgbm90IGNhdGNoIGl0IGFuZCB0dXJuIGl0IGludG8gYSByZWplY3Rpb24uXG4gICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbWFrZVN0YWNrVHJhY2VMb25nKGVycm9yLCBwcm9taXNlKTtcbiAgICAgICAgICAgIGlmIChRLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBRLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IGBuZXh0VGlja2BpbmcgdmlhIGFuIHVubmVjZXNzYXJ5IGB3aGVuYC5cbiAgICB2YXIgcHJvbWlzZSA9IGZ1bGZpbGxlZCB8fCByZWplY3RlZCB8fCBwcm9ncmVzcyA/XG4gICAgICAgIHRoaXMudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkLCBwcm9ncmVzcykgOlxuICAgICAgICB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgJiYgcHJvY2Vzcy5kb21haW4pIHtcbiAgICAgICAgb25VbmhhbmRsZWRFcnJvciA9IHByb2Nlc3MuZG9tYWluLmJpbmQob25VbmhhbmRsZWRFcnJvcik7XG4gICAgfVxuXG4gICAgcHJvbWlzZS50aGVuKHZvaWQgMCwgb25VbmhhbmRsZWRFcnJvcik7XG59O1xuXG4vKipcbiAqIENhdXNlcyBhIHByb21pc2UgdG8gYmUgcmVqZWN0ZWQgaWYgaXQgZG9lcyBub3QgZ2V0IGZ1bGZpbGxlZCBiZWZvcmVcbiAqIHNvbWUgbWlsbGlzZWNvbmRzIHRpbWUgb3V0LlxuICogQHBhcmFtIHtBbnkqfSBwcm9taXNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWlsbGlzZWNvbmRzIHRpbWVvdXRcbiAqIEBwYXJhbSB7QW55Kn0gY3VzdG9tIGVycm9yIG1lc3NhZ2Ugb3IgRXJyb3Igb2JqZWN0IChvcHRpb25hbClcbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UgaWYgaXQgaXNcbiAqIGZ1bGZpbGxlZCBiZWZvcmUgdGhlIHRpbWVvdXQsIG90aGVyd2lzZSByZWplY3RlZC5cbiAqL1xuUS50aW1lb3V0ID0gZnVuY3Rpb24gKG9iamVjdCwgbXMsIGVycm9yKSB7XG4gICAgcmV0dXJuIFEob2JqZWN0KS50aW1lb3V0KG1zLCBlcnJvcik7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zLCBlcnJvcikge1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgdmFyIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWVycm9yIHx8IFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvcikge1xuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZXJyb3IgfHwgXCJUaW1lZCBvdXQgYWZ0ZXIgXCIgKyBtcyArIFwiIG1zXCIpO1xuICAgICAgICAgICAgZXJyb3IuY29kZSA9IFwiRVRJTUVET1VUXCI7XG4gICAgICAgIH1cbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICB9LCBtcyk7XG5cbiAgICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbHVlKTtcbiAgICB9LCBmdW5jdGlvbiAoZXhjZXB0aW9uKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICB9LCBkZWZlcnJlZC5ub3RpZnkpO1xuXG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZ2l2ZW4gdmFsdWUgKG9yIHByb21pc2VkIHZhbHVlKSwgc29tZVxuICogbWlsbGlzZWNvbmRzIGFmdGVyIGl0IHJlc29sdmVkLiBQYXNzZXMgcmVqZWN0aW9ucyBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7QW55Kn0gcHJvbWlzZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbGxpc2Vjb25kc1xuICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2l2ZW4gcHJvbWlzZSBhZnRlciBtaWxsaXNlY29uZHNcbiAqIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdpdmVuIHByb21pc2UuXG4gKiBJZiB0aGUgZ2l2ZW4gcHJvbWlzZSByZWplY3RzLCB0aGF0IGlzIHBhc3NlZCBpbW1lZGlhdGVseS5cbiAqL1xuUS5kZWxheSA9IGZ1bmN0aW9uIChvYmplY3QsIHRpbWVvdXQpIHtcbiAgICBpZiAodGltZW91dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdCA9IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIFEob2JqZWN0KS5kZWxheSh0aW1lb3V0KTtcbn07XG5cblByb21pc2UucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUodmFsdWUpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFBhc3NlcyBhIGNvbnRpbnVhdGlvbiB0byBhIE5vZGUgZnVuY3Rpb24sIHdoaWNoIGlzIGNhbGxlZCB3aXRoIHRoZSBnaXZlblxuICogYXJndW1lbnRzIHByb3ZpZGVkIGFzIGFuIGFycmF5LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKlxuICogICAgICBRLm5mYXBwbHkoRlMucmVhZEZpbGUsIFtfX2ZpbGVuYW1lXSlcbiAqICAgICAgLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAqICAgICAgfSlcbiAqXG4gKi9cblEubmZhcHBseSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5uZmFwcGx5KGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZhcHBseSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmdzKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgdGhpcy5mYXBwbHkobm9kZUFyZ3MpLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogUGFzc2VzIGEgY29udGludWF0aW9uIHRvIGEgTm9kZSBmdW5jdGlvbiwgd2hpY2ggaXMgY2FsbGVkIHdpdGggdGhlIGdpdmVuXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgaW5kaXZpZHVhbGx5LCBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZXhhbXBsZVxuICogUS5uZmNhbGwoRlMucmVhZEZpbGUsIF9fZmlsZW5hbWUpXG4gKiAudGhlbihmdW5jdGlvbiAoY29udGVudCkge1xuICogfSlcbiAqXG4gKi9cblEubmZjYWxsID0gZnVuY3Rpb24gKGNhbGxiYWNrIC8qLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBRKGNhbGxiYWNrKS5uZmFwcGx5KGFyZ3MpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZjYWxsID0gZnVuY3Rpb24gKC8qLi4uYXJncyovKSB7XG4gICAgdmFyIG5vZGVBcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlO1xufTtcblxuLyoqXG4gKiBXcmFwcyBhIE5vZGVKUyBjb250aW51YXRpb24gcGFzc2luZyBmdW5jdGlvbiBhbmQgcmV0dXJucyBhbiBlcXVpdmFsZW50XG4gKiB2ZXJzaW9uIHRoYXQgcmV0dXJucyBhIHByb21pc2UuXG4gKiBAZXhhbXBsZVxuICogUS5uZmJpbmQoRlMucmVhZEZpbGUsIF9fZmlsZW5hbWUpKFwidXRmLThcIilcbiAqIC50aGVuKGNvbnNvbGUubG9nKVxuICogLmRvbmUoKVxuICovXG5RLm5mYmluZCA9XG5RLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChjYWxsYmFjayAvKi4uLmFyZ3MqLykge1xuICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlEgY2FuJ3Qgd3JhcCBhbiB1bmRlZmluZWQgZnVuY3Rpb25cIik7XG4gICAgfVxuICAgIHZhciBiYXNlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gYmFzZUFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIFEoY2FsbGJhY2spLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmZiaW5kID1cblByb21pc2UucHJvdG90eXBlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uICgvKi4uLmFyZ3MqLykge1xuICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UoYXJndW1lbnRzKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgcmV0dXJuIFEuZGVub2RlaWZ5LmFwcGx5KHZvaWQgMCwgYXJncyk7XG59O1xuXG5RLm5iaW5kID0gZnVuY3Rpb24gKGNhbGxiYWNrLCB0aGlzcCAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBiYXNlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vZGVBcmdzID0gYmFzZUFyZ3MuY29uY2F0KGFycmF5X3NsaWNlKGFyZ3VtZW50cykpO1xuICAgICAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgICAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgICAgIGZ1bmN0aW9uIGJvdW5kKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXNwLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIFEoYm91bmQpLmZhcHBseShub2RlQXJncykuZmFpbChkZWZlcnJlZC5yZWplY3QpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9O1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUubmJpbmQgPSBmdW5jdGlvbiAoLyp0aGlzcCwgLi4uYXJncyovKSB7XG4gICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDApO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICByZXR1cm4gUS5uYmluZC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCBvZiBhIE5vZGUtc3R5bGUgb2JqZWN0IHRoYXQgYWNjZXB0cyBhIE5vZGUtc3R5bGVcbiAqIGNhbGxiYWNrIHdpdGggYSBnaXZlbiBhcnJheSBvZiBhcmd1bWVudHMsIHBsdXMgYSBwcm92aWRlZCBjYWxsYmFjay5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIG1ldGhvZDsgdGhlIGNhbGxiYWNrXG4gKiB3aWxsIGJlIHByb3ZpZGVkIGJ5IFEgYW5kIGFwcGVuZGVkIHRvIHRoZXNlIGFyZ3VtZW50cy5cbiAqIEByZXR1cm5zIGEgcHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9yIGVycm9yXG4gKi9cblEubm1hcHBseSA9IC8vIFhYWCBBcyBwcm9wb3NlZCBieSBcIlJlZHNhbmRyb1wiXG5RLm5wb3N0ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgYXJncykge1xuICAgIHJldHVybiBRKG9iamVjdCkubnBvc3QobmFtZSwgYXJncyk7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5ubWFwcGx5ID0gLy8gWFhYIEFzIHByb3Bvc2VkIGJ5IFwiUmVkc2FuZHJvXCJcblByb21pc2UucHJvdG90eXBlLm5wb3N0ID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmdzIHx8IFtdKTtcbiAgICB2YXIgZGVmZXJyZWQgPSBkZWZlcigpO1xuICAgIG5vZGVBcmdzLnB1c2goZGVmZXJyZWQubWFrZU5vZGVSZXNvbHZlcigpKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIG9mIGEgTm9kZS1zdHlsZSBvYmplY3QgdGhhdCBhY2NlcHRzIGEgTm9kZS1zdHlsZVxuICogY2FsbGJhY2ssIGZvcndhcmRpbmcgdGhlIGdpdmVuIHZhcmlhZGljIGFyZ3VtZW50cywgcGx1cyBhIHByb3ZpZGVkXG4gKiBjYWxsYmFjayBhcmd1bWVudC5cbiAqIEBwYXJhbSBvYmplY3QgYW4gb2JqZWN0IHRoYXQgaGFzIHRoZSBuYW1lZCBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5hbWUgb2YgdGhlIG1ldGhvZCBvZiBvYmplY3RcbiAqIEBwYXJhbSAuLi5hcmdzIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBtZXRob2Q7IHRoZSBjYWxsYmFjayB3aWxsXG4gKiBiZSBwcm92aWRlZCBieSBRIGFuZCBhcHBlbmRlZCB0byB0aGVzZSBhcmd1bWVudHMuXG4gKiBAcmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSB2YWx1ZSBvciBlcnJvclxuICovXG5RLm5zZW5kID0gLy8gWFhYIEJhc2VkIG9uIE1hcmsgTWlsbGVyJ3MgcHJvcG9zZWQgXCJzZW5kXCJcblEubm1jYWxsID0gLy8gWFhYIEJhc2VkIG9uIFwiUmVkc2FuZHJvJ3NcIiBwcm9wb3NhbFxuUS5uaW52b2tlID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSAvKi4uLmFyZ3MqLykge1xuICAgIHZhciBub2RlQXJncyA9IGFycmF5X3NsaWNlKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGRlZmVycmVkID0gZGVmZXIoKTtcbiAgICBub2RlQXJncy5wdXNoKGRlZmVycmVkLm1ha2VOb2RlUmVzb2x2ZXIoKSk7XG4gICAgUShvYmplY3QpLmRpc3BhdGNoKFwicG9zdFwiLCBbbmFtZSwgbm9kZUFyZ3NdKS5mYWlsKGRlZmVycmVkLnJlamVjdCk7XG4gICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZS5uc2VuZCA9IC8vIFhYWCBCYXNlZCBvbiBNYXJrIE1pbGxlcidzIHByb3Bvc2VkIFwic2VuZFwiXG5Qcm9taXNlLnByb3RvdHlwZS5ubWNhbGwgPSAvLyBYWFggQmFzZWQgb24gXCJSZWRzYW5kcm8nc1wiIHByb3Bvc2FsXG5Qcm9taXNlLnByb3RvdHlwZS5uaW52b2tlID0gZnVuY3Rpb24gKG5hbWUgLyouLi5hcmdzKi8pIHtcbiAgICB2YXIgbm9kZUFyZ3MgPSBhcnJheV9zbGljZShhcmd1bWVudHMsIDEpO1xuICAgIHZhciBkZWZlcnJlZCA9IGRlZmVyKCk7XG4gICAgbm9kZUFyZ3MucHVzaChkZWZlcnJlZC5tYWtlTm9kZVJlc29sdmVyKCkpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwb3N0XCIsIFtuYW1lLCBub2RlQXJnc10pLmZhaWwoZGVmZXJyZWQucmVqZWN0KTtcbiAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbn07XG5cbi8qKlxuICogSWYgYSBmdW5jdGlvbiB3b3VsZCBsaWtlIHRvIHN1cHBvcnQgYm90aCBOb2RlIGNvbnRpbnVhdGlvbi1wYXNzaW5nLXN0eWxlIGFuZFxuICogcHJvbWlzZS1yZXR1cm5pbmctc3R5bGUsIGl0IGNhbiBlbmQgaXRzIGludGVybmFsIHByb21pc2UgY2hhaW4gd2l0aFxuICogYG5vZGVpZnkobm9kZWJhY2spYCwgZm9yd2FyZGluZyB0aGUgb3B0aW9uYWwgbm9kZWJhY2sgYXJndW1lbnQuICBJZiB0aGUgdXNlclxuICogZWxlY3RzIHRvIHVzZSBhIG5vZGViYWNrLCB0aGUgcmVzdWx0IHdpbGwgYmUgc2VudCB0aGVyZS4gIElmIHRoZXkgZG8gbm90XG4gKiBwYXNzIGEgbm9kZWJhY2ssIHRoZXkgd2lsbCByZWNlaXZlIHRoZSByZXN1bHQgcHJvbWlzZS5cbiAqIEBwYXJhbSBvYmplY3QgYSByZXN1bHQgKG9yIGEgcHJvbWlzZSBmb3IgYSByZXN1bHQpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBub2RlYmFjayBhIE5vZGUuanMtc3R5bGUgY2FsbGJhY2tcbiAqIEByZXR1cm5zIGVpdGhlciB0aGUgcHJvbWlzZSBvciBub3RoaW5nXG4gKi9cblEubm9kZWlmeSA9IG5vZGVpZnk7XG5mdW5jdGlvbiBub2RlaWZ5KG9iamVjdCwgbm9kZWJhY2spIHtcbiAgICByZXR1cm4gUShvYmplY3QpLm5vZGVpZnkobm9kZWJhY2spO1xufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKG5vZGViYWNrKSB7XG4gICAgaWYgKG5vZGViYWNrKSB7XG4gICAgICAgIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKG51bGwsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIFEubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG5vZGViYWNrKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59O1xuXG5RLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJRLm5vQ29uZmxpY3Qgb25seSB3b3JrcyB3aGVuIFEgaXMgdXNlZCBhcyBhIGdsb2JhbFwiKTtcbn07XG5cbi8vIEFsbCBjb2RlIGJlZm9yZSB0aGlzIHBvaW50IHdpbGwgYmUgZmlsdGVyZWQgZnJvbSBzdGFjayB0cmFjZXMuXG52YXIgcUVuZGluZ0xpbmUgPSBjYXB0dXJlTGluZSgpO1xuXG5yZXR1cm4gUTtcblxufSk7XG4iXSwibmFtZXMiOlsiZGVmaW5pdGlvbiIsImJvb3RzdHJhcCIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJzZXMiLCJvayIsIm1ha2VRIiwic2VsZiIsImdsb2JhbCIsIndpbmRvdyIsInByZXZpb3VzUSIsIlEiLCJub0NvbmZsaWN0IiwiRXJyb3IiLCJoYXNTdGFja3MiLCJlIiwic3RhY2siLCJxU3RhcnRpbmdMaW5lIiwiY2FwdHVyZUxpbmUiLCJxRmlsZU5hbWUiLCJub29wIiwibmV4dFRpY2siLCJoZWFkIiwidGFzayIsIm5leHQiLCJ0YWlsIiwiZmx1c2hpbmciLCJyZXF1ZXN0VGljayIsImlzTm9kZUpTIiwibGF0ZXJRdWV1ZSIsImZsdXNoIiwiZG9tYWluIiwiZW50ZXIiLCJydW5TaW5nbGUiLCJsZW5ndGgiLCJwb3AiLCJleGl0Iiwic2V0VGltZW91dCIsInByb2Nlc3MiLCJ0b1N0cmluZyIsInNldEltbWVkaWF0ZSIsImJpbmQiLCJNZXNzYWdlQ2hhbm5lbCIsImNoYW5uZWwiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInJlcXVlc3RQb3J0VGljayIsInBvcnQyIiwicG9zdE1lc3NhZ2UiLCJydW5BZnRlciIsInB1c2giLCJjYWxsIiwiRnVuY3Rpb24iLCJ1bmN1cnJ5VGhpcyIsImYiLCJhcHBseSIsImFyZ3VtZW50cyIsImFycmF5X3NsaWNlIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImFycmF5X3JlZHVjZSIsInJlZHVjZSIsImNhbGxiYWNrIiwiYmFzaXMiLCJpbmRleCIsIlR5cGVFcnJvciIsImFycmF5X2luZGV4T2YiLCJpbmRleE9mIiwidmFsdWUiLCJpIiwiYXJyYXlfbWFwIiwibWFwIiwidGhpc3AiLCJjb2xsZWN0IiwidW5kZWZpbmVkIiwib2JqZWN0X2NyZWF0ZSIsIk9iamVjdCIsImNyZWF0ZSIsIlR5cGUiLCJvYmplY3RfZGVmaW5lUHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsInByb3AiLCJkZXNjcmlwdG9yIiwib2JqZWN0X2hhc093blByb3BlcnR5IiwiaGFzT3duUHJvcGVydHkiLCJvYmplY3Rfa2V5cyIsImtleXMiLCJvYmplY3QiLCJrZXkiLCJvYmplY3RfdG9TdHJpbmciLCJpc09iamVjdCIsImlzU3RvcEl0ZXJhdGlvbiIsImV4Y2VwdGlvbiIsIlFSZXR1cm5WYWx1ZSIsIlJldHVyblZhbHVlIiwiU1RBQ0tfSlVNUF9TRVBBUkFUT1IiLCJtYWtlU3RhY2tUcmFjZUxvbmciLCJlcnJvciIsInByb21pc2UiLCJzdGFja3MiLCJwIiwic291cmNlIiwiX19taW5pbXVtU3RhY2tDb3VudGVyX18iLCJzdGFja0NvdW50ZXIiLCJjb25maWd1cmFibGUiLCJ1bnNoaWZ0IiwiY29uY2F0ZWRTdGFja3MiLCJqb2luIiwiZmlsdGVyU3RhY2tTdHJpbmciLCJzdGFja1N0cmluZyIsImxpbmVzIiwic3BsaXQiLCJkZXNpcmVkTGluZXMiLCJsaW5lIiwiaXNJbnRlcm5hbEZyYW1lIiwiaXNOb2RlRnJhbWUiLCJzdGFja0xpbmUiLCJnZXRGaWxlTmFtZUFuZExpbmVOdW1iZXIiLCJhdHRlbXB0MSIsImV4ZWMiLCJOdW1iZXIiLCJhdHRlbXB0MiIsImF0dGVtcHQzIiwiZmlsZU5hbWVBbmRMaW5lTnVtYmVyIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwicUVuZGluZ0xpbmUiLCJmaXJzdExpbmUiLCJkZXByZWNhdGUiLCJuYW1lIiwiYWx0ZXJuYXRpdmUiLCJjb25zb2xlIiwid2FybiIsIlByb21pc2UiLCJpc1Byb21pc2VBbGlrZSIsImNvZXJjZSIsImZ1bGZpbGwiLCJyZXNvbHZlIiwibG9uZ1N0YWNrU3VwcG9ydCIsImxvbmdTdGFja0NvdW50ZXIiLCJlbnYiLCJRX0RFQlVHIiwiZGVmZXIiLCJtZXNzYWdlcyIsInByb2dyZXNzTGlzdGVuZXJzIiwicmVzb2x2ZWRQcm9taXNlIiwiZGVmZXJyZWQiLCJwcm9taXNlRGlzcGF0Y2giLCJvcCIsIm9wZXJhbmRzIiwiYXJncyIsInZhbHVlT2YiLCJuZWFyZXJWYWx1ZSIsIm5lYXJlciIsImlzUHJvbWlzZSIsImluc3BlY3QiLCJzdGF0ZSIsInN1YnN0cmluZyIsImJlY29tZSIsIm5ld1Byb21pc2UiLCJtZXNzYWdlIiwicmVqZWN0IiwicmVhc29uIiwibm90aWZ5IiwicHJvZ3Jlc3MiLCJwcm9ncmVzc0xpc3RlbmVyIiwibWFrZU5vZGVSZXNvbHZlciIsInJlc29sdmVyIiwicmFjZSIsImFsbCIsInBhc3NCeUNvcHkiLCJ4IiwieSIsInRoYXQiLCJzcHJlYWQiLCJhbnN3ZXJQcyIsImxlbiIsInRoZW4iLCJtYWtlUHJvbWlzZSIsImZhbGxiYWNrIiwicmVzdWx0IiwiaW5zcGVjdGVkIiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJwcm9ncmVzc2VkIiwiZG9uZSIsIl9mdWxmaWxsZWQiLCJfcmVqZWN0ZWQiLCJuZXdFeGNlcHRpb24iLCJfcHJvZ3Jlc3NlZCIsIm5ld1ZhbHVlIiwidGhyZXciLCJvbmVycm9yIiwidGFwIiwiZmNhbGwiLCJ0aGVuUmVzb2x2ZSIsIndoZW4iLCJ0aGVuUmVqZWN0IiwiaXNQZW5kaW5nIiwiaXNGdWxmaWxsZWQiLCJpc1JlamVjdGVkIiwidW5oYW5kbGVkUmVhc29ucyIsInVuaGFuZGxlZFJlamVjdGlvbnMiLCJyZXBvcnRlZFVuaGFuZGxlZFJlamVjdGlvbnMiLCJ0cmFja1VuaGFuZGxlZFJlamVjdGlvbnMiLCJyZXNldFVuaGFuZGxlZFJlamVjdGlvbnMiLCJ0cmFja1JlamVjdGlvbiIsImVtaXQiLCJ1bnRyYWNrUmVqZWN0aW9uIiwiYXQiLCJhdFJlcG9ydCIsInNwbGljZSIsImdldFVuaGFuZGxlZFJlYXNvbnMiLCJzdG9wVW5oYW5kbGVkUmVqZWN0aW9uVHJhY2tpbmciLCJyZWplY3Rpb24iLCJyaHMiLCJtYXN0ZXIiLCJkaXNwYXRjaCIsImFycmF5IiwiYXN5bmMiLCJtYWtlR2VuZXJhdG9yIiwiY29udGludWVyIiwidmVyYiIsImFyZyIsIlN0b3BJdGVyYXRpb24iLCJnZW5lcmF0b3IiLCJlcnJiYWNrIiwic3Bhd24iLCJfcmV0dXJuIiwicHJvbWlzZWQiLCJnZXQiLCJzZXQiLCJkZWwiLCJtYXBwbHkiLCJwb3N0Iiwic2VuZCIsIm1jYWxsIiwiaW52b2tlIiwiZmFwcGx5IiwiZmJpbmQiLCJmYm91bmQiLCJjb25jYXQiLCJwcm9taXNlcyIsInBlbmRpbmdDb3VudCIsInNuYXBzaG90IiwiYW55IiwicHJldiIsImN1cnJlbnQiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJvblByb2dyZXNzIiwiZXJyIiwiYWxsUmVzb2x2ZWQiLCJhbGxTZXR0bGVkIiwicmVnYXJkbGVzcyIsImZhaWwiLCJmaW4iLCJvblVuaGFuZGxlZEVycm9yIiwidGltZW91dCIsIm1zIiwidGltZW91dElkIiwiY29kZSIsImNsZWFyVGltZW91dCIsImRlbGF5IiwibmZhcHBseSIsIm5vZGVBcmdzIiwibmZjYWxsIiwibmZiaW5kIiwiZGVub2RlaWZ5IiwiYmFzZUFyZ3MiLCJuYmluZCIsImJvdW5kIiwibm1hcHBseSIsIm5wb3N0IiwibnNlbmQiLCJubWNhbGwiLCJuaW52b2tlIiwibm9kZWlmeSIsIm5vZGViYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/q/q.js\n");

/***/ })

};
;